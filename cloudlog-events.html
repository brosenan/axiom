
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <link rel="shortcut icon" href="favicon.ico">
  <title><img src="img/axiom-logo.png">//cloudlog-events.core - Event Processing</title>
  <script src="js/highlight.min.js"></script>
  <script src="js/gumshoe.min.js"></script>
  <script src="js/smooth-scroll.min.js"></script>
  
  <!-- CSS -->
  <link rel="stylesheet" href="css/poole.css">
  <link rel="stylesheet" href="css/syntax.css">
  <link rel="stylesheet" href="css/lanyon.css">
  <link rel="stylesheet" href="css/bolton.css">
  <link rel="stylesheet" href="css/bolton-api.css">
  <link rel="stylesheet" href="css/bolton-highlight.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">
  
</head>

  <body class="theme-base-08">
    <span id="page-top"></span>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <nav class="sidebar-nav">
    <span>&nbsp;</span>
    <a class="sidebar-nav-item header" href="index.html"><img src="img/logo-white.png"/></a>
    <span>&nbsp;</span>
    <a class="sidebar-nav-item" href="cloudlog.html">cloudlog.core</a><a class="sidebar-nav-item active" href="cloudlog-events.html">cloudlog-events.core</a><a class="sidebar-nav-item" href="cloudlog.graph.html">cloudlog.graph</a><a class="sidebar-nav-item" href="cloudlog.interset.html">cloudlog.interset</a><a class="sidebar-nav-item" href="dynamo.html">dynamo.core</a><a class="sidebar-nav-item" href="dynamo.srv.html">dynamo.srv</a><a class="sidebar-nav-item" href="rabbit-microservices.html">rabbit-microservices.core</a><a class="sidebar-nav-item" href="zk-plan.html">zk-plan.core</a>
    <span class="sidebar-nav-item">&nbsp;</span>
    <span class="sidebar-nav-item">&nbsp;</span>
  </nav>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <span>axiom//cloudlog-events.core</span>
            <small>Event Processing</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="page">
          <div class="heading">
            <div>
              <h5>Author: Boaz Rosenan&nbsp;&nbsp;<a href="mailto:brosenan@gmail.com">(brosenan@gmail.com)</a></h5>
              <h5>Date: 15 April 2017</h5>
              <h5>Repository: <a href="https://github.com/brosenan/cloudlog.clj">https://github.com/brosenan/cloudlog.clj</a></h5>
              <h5>Version: 0.1.0-SNAPSHOT</h5></div></div>
          <hr/>
          <div class="outline">
            <div class="toc">
              <nav data-gumshoe-header>
                <ul data-gumshoe>
                  <a data-scroll class="top" href="#page-top">TOP</a>
                  <li><a class="chapter" data-scroll="" href="#introduction"><h4>1 &nbsp; Introduction</h4></a><a class="section" data-scroll="" href="#rules"><h5><i>1.1 &nbsp; Rules</i></h5></a></li><li><a class="chapter" data-scroll="" href="#emitter-create-an-event-emitting-function"><h4>2 &nbsp; emitter: Create an Event-Emitting Function</h4></a><a class="section" data-scroll="" href="#writers"><h5><i>2.1 &nbsp; Readers and Writers</i></h5></a></li><li><a class="chapter" data-scroll="" href="#multiplier"><h4>3 &nbsp; multiplier: Create a Function Applying Rules to Facts</h4></a><a class="section" data-scroll="" href="#confidentiality"><h5><i>3.1 &nbsp; Confidentiality</i></h5></a><a class="section" data-scroll="" href="#integrity"><h5><i>3.2 &nbsp; Integrity</i></h5></a><a class="section" data-scroll="" href="#timestamps"><h5><i>3.3 &nbsp; Timestamps</i></h5></a></li><li><a class="chapter" data-scroll="" href="#matcher"><h4>4 &nbsp; matcher: Matches Rules and Facts</h4></a><a class="section" data-scroll="" href="#matching-rules-for-facts"><h5><i>4.1 &nbsp; Matching Rules for Facts</i></h5></a><a class="section" data-scroll="" href="#matching-facts-for-rules"><h5><i>4.2 &nbsp; Matching Facts for Rules</i></h5></a></li>
                </ul>
              </nav>
            </div>
          </div>

          <div class="toc">
              <nav>
                <ul>
                  <li><a class="chapter" data-scroll="" href="#introduction"><h4>1 &nbsp; Introduction</h4></a><a class="section" data-scroll="" href="#rules"><h5><i>1.1 &nbsp; Rules</i></h5></a></li><li><a class="chapter" data-scroll="" href="#emitter-create-an-event-emitting-function"><h4>2 &nbsp; emitter: Create an Event-Emitting Function</h4></a><a class="section" data-scroll="" href="#writers"><h5><i>2.1 &nbsp; Readers and Writers</i></h5></a></li><li><a class="chapter" data-scroll="" href="#multiplier"><h4>3 &nbsp; multiplier: Create a Function Applying Rules to Facts</h4></a><a class="section" data-scroll="" href="#confidentiality"><h5><i>3.1 &nbsp; Confidentiality</i></h5></a><a class="section" data-scroll="" href="#integrity"><h5><i>3.2 &nbsp; Integrity</i></h5></a><a class="section" data-scroll="" href="#timestamps"><h5><i>3.3 &nbsp; Timestamps</i></h5></a></li><li><a class="chapter" data-scroll="" href="#matcher"><h4>4 &nbsp; matcher: Matches Rules and Facts</h4></a><a class="section" data-scroll="" href="#matching-rules-for-facts"><h5><i>4.1 &nbsp; Matching Rules for Facts</i></h5></a><a class="section" data-scroll="" href="#matching-facts-for-rules"><h5><i>4.2 &nbsp; Matching Facts for Rules</i></h5></a></li>
                </ul>
              </nav>
          </div>
          <div><span id="introduction"></span><h2><b>1 &nbsp;&nbsp; Introduction</b></h2></div><div><p><code>defrule</code> and <code>defclause</code> allow users to define logic that defines applications. These macros actually define <em>rule functions</em>, which are Clojure functions with metadata, intended to process <em>facts</em> and create new facts based on them. See <a href='cloudlog.html'>core</a> for more details.</p></div><div><p>The <code>cloudlog.events</code> package provides functions for applying rule functions on events. An <em>event</em> is a Clojure map, containing a single change in the state of the application. This change can be an addition of a fact, a removal of a fact, or the effect of such event on the internal state of a rule. Each event contains the following fields:</p><ul><li><code>:kind</code>: Either <code>:fact</code>, if this event represent a change to a fact, or <code>:rule</code> if it represents a change to a rule.</li><li><code>:name</code>: A string representing the name of the stream this event belongs to.  See <a href='cloudlog.html#fact-table-get-a-fully-qualified-name-for-a-fact'>fact-table</a> for details.</li><li><code>:key</code>: The key of the fact or the rule.  See <a href='cloudlog.html#joins'>here</a> for more details.</li><li><code>:ts</code>: The time (in milliseconds since EPOCH) in which this event was created (for facts.  See below for rules).</li><li><code>:data</code>: The data tuple representing a fact, or the state of a rule, excluding the key.</li><li><code>:change</code>: A number representing the change.  Typically, <code>1</code> represents addition, and <code>-1</code> represents removal.</li><li><code>:writers</code>: The event's <em>writer-set</em>, represented as an <a href='cloudlog.interset.html'>interset</a>.</li><li><code>:readers</code>: The event's <em>reader-set</em>, represented as an <a href='cloudlog.interset.html'>interset</a>.</li></ul></div><div><p>For the examples of this package we will use the following convenience function:</p></div><div class="code"><pre><code class="clojure">(defn event [kind name key data &amp; {:keys [ts change writers readers] :or {ts 1000
                                                                          change 1
                                                                          writers #{}
                                                                          readers #{}}}]
  {:kind kind
   :name name
   :key key
   :data data
   :ts ts
   :change change
   :writers writers
   :readers readers})</code></pre></div><div class="code"><pre><code class="clojure">(event :fact &quot;foo&quot; 13 [&quot;a&quot; &quot;b&quot;] :ts 2000) =&gt; {:kind :fact
                                             :name &quot;foo&quot;
                                             :key 13
                                             :data [&quot;a&quot; &quot;b&quot;]
                                             :ts 2000
                                             :change 1
                                             :writers #{}
                                             :readers #{}}</code></pre></div><div><span id="rules"></span><h3>1.1 &nbsp;&nbsp; Rules</h3></div><div><p>In this module we base our examples on the following rules defined <a href='cloudlog.html'>here</a>:</p></div><div class="code"><pre><code class="clojure">(cloudlog/defrule foo-yx [y x]
  [:test/foo x y] (cloudlog/by-anyone))

(cloudlog/defrule timeline [user tweet]
  [:test/follows user author] (cloudlog/by-anyone)
  [:test/tweeted author tweet] (cloudlog/by-anyone))</code></pre></div><div><span id="emitter-create-an-event-emitting-function"></span><h2><b>2 &nbsp;&nbsp; emitter: Create an Event-Emitting Function</b></h2></div><div><p>Rules start by matching a single fact.  An emitter function takes an event representing such a fact and applies the rule function associated with the event.</p></div><div><p>For a simple rule, the result is a sequence of derived fact.</p></div><div class="code"><pre><code class="clojure">(let [em (emitter foo-yx #{})]
 (em (event :fact &quot;test/foo&quot; 2 [3]))
 =&gt; [(event :fact &quot;cloudlog-events.core_test/foo-yx&quot; 3 [2])])</code></pre></div><div><p>For a join, the result is an event representing the <em>rule</em> produced from the fact.</p><p>Here some explanation is in order.  Our notion of facts and rules come from mathematical logic. Facts are what mathematical logic calls <em>atoms</em> &ndash; a combination of a name with some arguments, and rules are logic formulas of the form <code>a-&gt;b</code>, where the <code>-&gt;</code> operator represents logical inference. In the subset of mathematical logic we adopted, the left-hand-side of the <code>-&gt;</code> operator must be an atom (a fact).  However, the right-hand side can be any kind of axiom &ndash; fact or rule.  With this we can create compound rules such as <code>a-&gt;b-&gt;c-&gt;d</code>, that should be read as <code>a-&gt;&#40;b-&gt;&#40;c-&gt;d&#41;&#41;</code>. This means that the fact <code>a</code> implies the rule <code>b-&gt;c-&gt;d</code>, which in turn means that the fact <code>b</code> implies <code>c-&gt;d</code>, which in turn means that <code>c</code> implies <code>d</code>. In cloudlog.clj, rule functions take whatever matches the left-hand side of the rule, and emit whatever is on the right-hand side, be it a (derived) fact or a rule. Our implementation does not emit the rule syntactically.  Instead it provides a tuple that contains its underlying data.  But we still treat it as a rule.</p></div><div class="code"><pre><code class="clojure">(let [em (emitter timeline #{})]
 (em (event :fact &quot;test/follows&quot; &quot;alice&quot; [&quot;bob&quot;]))
 =&gt; [(event :rule &quot;cloudlog-events.core_test/timeline!0&quot; &quot;bob&quot; [&quot;alice&quot; &quot;bob&quot;])])</code></pre></div><div><p>The <code>:name</code> component in the produced events is derived from the name of the rule, a 'bang' (<code>!</code>) and the index of the link that emitted this event in the overall rule.  An emitter always represents the first link in a rule, so this value is always 0.</p></div><div><span id="writers"></span><h3>2.1 &nbsp;&nbsp; Readers and Writers</h3></div><div><p>The only parts of the event that are not easy to understand are the <code>:readers</code> and <code>:writers</code> keys. The values associated with these keys are conceptually <em>sets of users</em>. <code>:writers</code> represents the set of users who <em>may have created</em> the event. Each user in this set has permission to create a similar event that, e.g., can cancel the effect of this one (e.g., by creating an event with the same <code>:key</code>, <code>:data</code> <code>:readers</code> and <code>writers</code> but with a complement <code>:change</code> value) and to replace the underlying datum with another one (e.g., by creating an event with the same <code>:key</code>, <code>:readers</code> and <code>:writers</code> but different <code>:data</code>. The <code>:writers</code> set is key to how Clojure applications manage <em>integrity</em>.</p></div><div><p>When a rule is applied to a fact, the resulting event carries the <code>:writers</code> set associated with the rule.  The <code>emitter</code> function takes its <code>:writers</code> set as a second argument. Typically, an application's writer is represented by its Internet domain</p></div><div class="code"><pre><code class="clojure">(let [em (emitter foo-yx #{&quot;example.com&quot;})]
 (em (event :fact &quot;test/foo&quot; 2 [3] :writers #{:foo :bar}))
 =&gt; [(event :fact &quot;cloudlog-events.core_test/foo-yx&quot; 3 [2] :writers #{&quot;example.com&quot;})])</code></pre></div><div><p><code>:readers</code> represents a set of users allowed to read an axiom. We will revisit <code>:readers</code> when discussing <a href='#multiplier'>multiplier</a>.</p></div><div><p>Rules may pose requirements for <code>:writers</code> and <code>:readers</code>. To support this, we pass them as metadata on the data.</p></div><div class="code"><pre><code class="clojure">(let [some-rule (fn [vec]
                 (when-not (= (meta vec) {:writers #{:w}
                                          :readers #{:r}})
                   (throw (Exception. &quot;Did not get readers and writers as meta&quot;))))
     em (emitter some-rule #{})]
 (em (event :fact &quot;something&quot; 1 [2 3] :writers #{:w} :readers #{:r}))
 =&gt; irrelevant)</code></pre></div><div><span id="multiplier"></span><h2><b>3 &nbsp;&nbsp; multiplier: Create a Function Applying Rules to Facts</b></h2></div><div><p>The lowest level of event processing is taking two corresponding events  (i.e., an event for a fact and a rule with the same key) and producing a collection of events that are produced from this combination.</p></div><div><p>A multiplier is constructed based on a rule function, and a number (>0) representing the link in the rule.</p></div><div class="code"><pre><code class="clojure">(def mult1 (multiplier timeline 1))</code></pre></div><div><p>The returned function takes two arguments: a <em>rule event</em> and a matching <em>fact event</em>. It returns a sequence of events created by this combination.</p></div><div class="code"><pre><code class="clojure">(mult1 (event :rule &quot;cloudlog-events.core_test/timeline!0&quot; &quot;bob&quot; [&quot;alice&quot; &quot;bob&quot;])
      (event :fact &quot;test/tweeted&quot; &quot;bob&quot; [&quot;something&quot;]))
 =&gt; [(event :fact &quot;cloudlog-events.core_test/timeline&quot; &quot;alice&quot; [&quot;something&quot;])]</code></pre></div><div><p>We call this unit a <em>multiplier</em>, because it multiplies the <code>:change</code> field of the rule and the fact event. Imagine we have <code>n</code> facts and <code>m</code> rules with a certain key.  In order to have all possible derived events we should invoke the multiplier function <code>n&#42;m</code> times, once for each combination. Now imagine these <code>n</code> facts are actually the same fact, just added <code>n</code> times, and the <code>m</code> rules are the same rule added <code>m</code> times.  The state of the application can therefore be represented using two events, one for the fact, with <code>:change</code> value of <code>n</code>, and one for the rule with <code>:change</code> value of <code>m</code>. Now if we introduce these two events to the multiplier function, we would like to get the same result as before, that is, applying the rule to the fact <code>n&#42;m</code> times.  To achieve this, the multiplier function multiplies the <code>:change</code> values, so that every event it returns has a <code>:change</code> value of <code>n&#42;m</code>.</p></div><div class="code"><pre><code class="clojure">(mult1 (event :rule &quot;cloudlog-events.core_test/timeline!0&quot; &quot;bob&quot; [&quot;alice&quot; &quot;bob&quot;] :change 2)
      (event :fact &quot;test/tweeted&quot; &quot;bob&quot; [&quot;something&quot;] :change 3))
 =&gt; [(event :fact &quot;cloudlog-events.core_test/timeline&quot; &quot;alice&quot; [&quot;something&quot;] :change 6)]</code></pre></div><div><span id="confidentiality"></span><h3>3.1 &nbsp;&nbsp; Confidentiality</h3></div><div><p>A multiplier is a meeting place of facts with rules, which in turn are derived from other facts. Such a meeting place is where the <em>confidentiality</em> of the system is put to the test.</p></div><div><p>Consider a dating service, where users can open <em>tickets</em> with their personal details, set up a <em>watch</em> for tickets that match certain criteria (for simplicity, let's say, gender, location, and age-range). A rule for creating search results can look like this:</p></div><div class="code"><pre><code class="clojure">(cloudlog/defrule ticket-by-gender-and-location [[gender loc] ticket-id age]
  [:test/ticket ticket-id gender age loc] (cloudlog/by-anyone))

(cloudlog/defrule dating-matches [watch-id ticket-id]
  [:test/watch watch-id gender loc min-age max-age] (cloudlog/by-anyone)
  [ticket-by-gender-and-location [gender loc] ticket-id age] (cloudlog/by-anyone)
  (when (and (&lt;= age max-age)
             (&gt;= age min-age))))</code></pre></div><div><p><code>ticket-by-gender-and-location</code> is an indexing of raw <code>:test/ticket</code>, performed by the following rule:</p></div><div><p>People openning tickets on dating services often wish their tickets to be limited to a certain set of users.  Similarly, people setting up a watch often wish to keep their preferences secret. These preferences are recorded in the <code>:readers</code> set of each fact. <code>:readers</code> is an <a href='cloudlog.interset.html'>interset</a> specifying who can read this fact. Each element in <code>:readers</code> represents a <em>named set</em> of users, and the <em>readers set</em> for the event is an intersection of all these named sets.</p><p>In Cloudlog, rules are not responsible for confidentiality; the Cloudlog implementation is. Imagine a Alice openning a ticket in the dating service, willing to make it visible only to  <code>:male</code> <code>:long-time-users</code> (i.e., to members of the intersection of the <code>:male</code> and <code>:long-time-users</code> named sets).  The event will look like this:</p></div><div class="code"><pre><code class="clojure">(def alices-ticket-event
  (event :fact &quot;:test/ticket&quot; 1234 [:female 35 &quot;NYC&quot;]
         :readers #{:male :long-time-users}))</code></pre></div><div><p>The <code>emitter</code> applying the <code>ticket-by-gender-and-location</code> rule will keep the <code>:readers</code> set as-is:</p></div><div class="code"><pre><code class="clojure">(def ticket-by-gender-and-location-event
  (let [em (emitter ticket-by-gender-and-location #{&quot;dating-app.com&quot;})]
    (first (em alices-ticket-event))))</code></pre></div><div class="code"><pre><code class="clojure">(:readers ticket-by-gender-and-location-event) =&gt; #{:male :long-time-users}</code></pre></div><div><p>When Bob looks for dates like Alice, he creates <code>:test/watch</code> with an event looking like this:</p></div><div class="code"><pre><code class="clojure">(def bobs-watch-event
  (event :fact &quot;:test/watch&quot; 9876 [:female &quot;NYC&quot; 30 40]
         :readers #{:male [:user= &quot;bob&quot;]}))</code></pre></div><div><p>He places only himself in the <code>:readers</code> set, so no one else will know he's looking, or what he's looking for. Bob can be seen as an intersection of all the named sets he's a member of.  One such set is <code>&#91;:user= &quot;bob&quot;&#93;</code>, a partition set that contains only him, but Bob is also a member of the <code>:male</code> set. Note that Bob is not a member of the <code>:long-time-users</code> set, since he's new to the service.</p><p>Here too, the <code>emitter</code> function does not change the <code>:readers</code> set.</p></div><div class="code"><pre><code class="clojure">(def dating-matches-event
  (let [em (emitter dating-matches #{&quot;dating-app.com&quot;})]
    (first (em bobs-watch-event))))</code></pre></div><div class="code"><pre><code class="clojure">(:readers dating-matches-event) =&gt; #{:male [:user= &quot;bob&quot;]}</code></pre></div><div><p>Now is where things get interesting.  When the second link of the <code>dating-matches</code> rule kicks in, taking both <code>dating-matches-event</code> as the rule-event and <code>ticket-by-gender-and-location-event</code> as its fact event. What shall the <code>:reader</code> set of the result be?  That of the rule, conveying Bob's wishes, or that of the fact, conveying Alice's wishes?</p></div><div><p>The <code>:readers</code> set of the resulting events will be an <em>intersection</em> of both <code>:readers</code> sets, (which is actually a <a href='cloudlog.interset.html#intersection'>union of the Clojure sets</a>).</p></div><div class="code"><pre><code class="clojure">(let [mult (multiplier dating-matches 1)
     ev (first (mult dating-matches-event ticket-by-gender-and-location-event))]
 (:readers ev) =&gt; #{:male [:user= &quot;bob&quot;] :long-time-users})</code></pre></div><div><p>The resulting <code>:readers</code> set is an intersection of <code>:male</code> and <code>&#91;:user= &quot;bob&quot;&#93;</code>, which Bob is a member of, with <code>:long-time-users</code>, which Bob is not a member of.  This places Bob outside the intersection, and therefore unable to see the resulting fact (which is what we expect).</p></div><div><span id="integrity"></span><h3>3.2 &nbsp;&nbsp; Integrity</h3></div><div><p>Since rules <a href='cloudlog.html#integrity'>take ownership over the resulting events</a>, the <code>:writers</code> set of events coming out of a multiplier must come from the rule event:</p></div><div class="code"><pre><code class="clojure">(let [mult (multiplier timeline 1)]
 (mult (event :rule &quot;cloudlog-events.core_test/timeline!0&quot; &quot;bob&quot; [&quot;alice&quot; &quot;bob&quot;] :writers #{&quot;example.com&quot;})
       (event :fact &quot;:test/tweeted&quot; &quot;bob&quot; [&quot;hello&quot;] :writers #{[:user= &quot;bob&quot;]}))
 =&gt; [(event :fact &quot;cloudlog-events.core_test/timeline&quot; &quot;alice&quot; [&quot;hello&quot;] :writers #{&quot;example.com&quot;})])</code></pre></div><div><span id="timestamps"></span><h3>3.3 &nbsp;&nbsp; Timestamps</h3></div><div><p>Events are stored with a primary key that combines <code>:key</code> and <code>:ts</code>.  Out of these, <code>:key</code> is used for <a href='https://en.wikipedia.org/wiki/Shard_%28database_architecture%29'>sharding</a>, and <code>:ts</code> is used for sorting. Typically, we will want to query events that share <code>:name</code> and <code>:key</code> values together, so it makes sense to store all of them together. The <code>:ts</code> provides an additional key, so we can refer to specific events that share <code>:name</code> and <code>:key</code>.</p></div><div><p>Some event processing systems like <a href='http://storm.apache.org/'>Apache Storm</a> guarantee <a href='http://storm.apache.org/releases/1.0.0/Guaranteeing-message-processing.html'>at least once</a> semantics. The advantage of this approach is that they guarantee that everything that needs to be processed gets processed, and do this at relatively low cost.  The disadvantage is that if we use such a mechanism we need to be able to cope with processing being done more than once. Cloudlog.clj copes with this in two ways:</p><ol><li>All computation in Cloudlog.clj is declarative, meaning that if you call a rule function twice with the same input you are guaranteed to get the same output.</li><li>We use a consistent unique key for each result, so that if we get the same result a second time, the new result gets "swallowed" by the old result.</li></ol><p>The unique ID we use is the timestamp &ndash; <code>:ts</code>.  Timestamps are given to <em>fact events</em> when they are created. Each timestamp in the system, whether it refers to a raw fact, derived fact or rule events, is always originally a timestamp given to a raw fact when it was created.  This takes the computation time out of the equation for calculating these timestamps.</p></div><div><p>An <code>emitter</code> function simply moves the <code>:ts</code> attribute from its input event to its output.</p></div><div class="code"><pre><code class="clojure">(let [em (emitter foo-yx #{})
     ev (first (em (event :fact &quot;:test/foo&quot; 1 [2] :ts 1234)))]
 (:ts ev) =&gt; 1234)</code></pre></div><div><p>For a <code>multiplier</code>, the question of which <code>:ts</code> value to produce is more complicated. Each of the input events (the rule and the fact) has a timestamp, so which one should we use? Because we want each timestamp to be a real timestamp (from a raw fact event), we need to take exactly one of them.  We take the one from the <em>fact</em>.</p></div><div class="code"><pre><code class="clojure">(let [mult (multiplier timeline 1)
     ev (first (mult (event :rule &quot;cloudlog-events.core_test/timeline!0&quot; &quot;bob&quot; [&quot;alice&quot; &quot;bob&quot;] :ts 2345)
                     (event :fact &quot;:test/tweeted&quot; &quot;bob&quot; [&quot;hello&quot;] :ts 3456)))]
 (:ts ev) =&gt; 3456)</code></pre></div><div><p>Why? because we need to keep the value unique per <code>:key</code>. Consider the above example.  If we take the rule <code>:ts</code> value, the <code>:ts</code> for each entry in Alice's timeline will be the <code>:ts</code> of the rule that was applied, which takes its <code>:ts</code> from the <code>:test/follows</code> fact. This means that every tweet made by Bob will appear in Alice's timeline with the same <code>:ts</code> value, and hence tweets will overrun one another.</p><p>But what guarantee do we have that if we take the fact's <code>:ts</code> we do not get into such a situation? There is no hard guarantee for that.  Hoever, the whole point of using rules it to <a href='https://en.wikipedia.org/wiki/Denormalization'>denormalize</a> the data so that it is searchable with different keys.  It is pointless to have a rule that keeps the same <code>:key</code>. Such rules can be easily converted to <a href='cloudlog.html#defclause'>clauses</a>, which do not require redundant information to be stored.</p></div><div><span id="matcher"></span><h2><b>4 &nbsp;&nbsp; matcher: Matches Rules and Facts</b></h2></div><div><p><a href='#multiplier'>multipliers</a> apply rules to facts, and expect to be given both as parameters.  However, in most cases we are only given one &ndash; a rule or a fact, and we need to apply that rule or that fact to all matching rules and facts. These matching rule and fact events are typically stored in some database. The database can provide all events that match a combination of <code>:kind</code>, <code>:name</code> and <code>:key</code>.</p></div><div><p>As we wish to decouple Cloudlog's implementation from any particular database, we use <code>core.async</code> channels to interact with the database.  We provide the event to be matched on a channel, along with a channel for the output, and in return <em>someone</em> provides us with the matching events on the channel we provided, and closes the channel. On the other side of the channel there could be an interface to a cloud database, an in-memory cache or a combination of the two.  We don't care as long as we get what we need from the other side of the channel.</p></div><div><p>A matcher instance is constructed by the <code>matcher</code> function, which is given a rule function, a link number and a channel to the database.</p></div><div class="code"><pre><code class="clojure">(def db-chan (async/chan 1000))
(def timeline-matcher (matcher timeline 1 db-chan))</code></pre></div><div><span id="matching-rules-for-facts"></span><h3>4.1 &nbsp;&nbsp; Matching Rules for Facts</h3></div><div><p>The returned matcher is a function that takes an event and an output channel for the resulting events.</p></div><div class="code"><pre><code class="clojure">(def res-chan (async/chan 1000))
(timeline-matcher (event :fact &quot;:test/tweeted&quot; &quot;bob&quot; [&quot;hello&quot;]) res-chan)</code></pre></div><div><p>The matcher will emit a query to the <code>db-chan</code>, specifying what it is looking for</p></div><div class="code"><pre><code class="clojure">(def db-request
 (async/alts!! [db-chan
                (async/timeout 100)]))</code></pre></div><div class="code"><pre><code class="clojure">(-&gt; db-request second) =&gt; db-chan</code></pre></div><div><p>The request consists of a pair <code>&#91;req chan&#93;</code>, where <code>req</code> is a partial event that matches what we are looking for:</p></div><div class="code"><pre><code class="clojure">(-&gt; db-request first first) =&gt; {:kind :rule
                               :name &quot;cloudlog-events.core_test/timeline!0&quot;
                               :key &quot;bob&quot;}</code></pre></div><div><p>And <code>chan</code> is the channel on which the database is expected to provide the reply</p></div><div class="code"><pre><code class="clojure">(def reply-chan (-&gt; db-request first second))</code></pre></div><div><p>Next, the database emits matching rules on the reply channel, and closes it.</p></div><div class="code"><pre><code class="clojure">(async/&gt;!! reply-chan (event :rule &quot;cloudlog-events.core_test/timeline!0&quot; &quot;bob&quot; [&quot;alice&quot; &quot;bob&quot;]))
(async/&gt;!! reply-chan (event :rule &quot;cloudlog-events.core_test/timeline!0&quot; &quot;bob&quot; [&quot;eve&quot; &quot;bob&quot;]))
(async/close! reply-chan)</code></pre></div><div><p>For each such event the matcher will emit the events obtained by multiplying the fact and the rules.</p></div><div class="code"><pre><code class="clojure">(async/alts!! [res-chan
              (async/timeout 100)]) =&gt; [(event :fact &quot;cloudlog-events.core_test/timeline&quot; &quot;alice&quot; [&quot;hello&quot;]) res-chan]
 (async/alts!! [res-chan
              (async/timeout 100)]) =&gt; [(event :fact &quot;cloudlog-events.core_test/timeline&quot; &quot;eve&quot; [&quot;hello&quot;]) res-chan]</code></pre></div><div><p>Finally, the channel needs to be closed.</p></div><div class="code"><pre><code class="clojure">(async/alts!! [res-chan
              (async/timeout 100)]) =&gt; [nil res-chan]</code></pre></div><div><span id="matching-facts-for-rules"></span><h3>4.2 &nbsp;&nbsp; Matching Facts for Rules</h3></div><div><p>A matcher function can accept either a fact event or a rule event.</p></div><div class="code"><pre><code class="clojure">(def res-chan (async/chan 1000))
(timeline-matcher (event :rule &quot;cloudlog-events.core_test/timeline!0&quot; &quot;bob&quot; [&quot;alice&quot; &quot;bob&quot;]) res-chan)</code></pre></div><div><p>For a rule, the matcher will query the database for matching facts.</p></div><div class="code"><pre><code class="clojure">(def db-request
 (async/alts!! [db-chan
                (async/timeout 100)]))</code></pre></div><div class="code"><pre><code class="clojure">(-&gt; db-request second) =&gt; db-chan</code></pre></div><div class="code"><pre><code class="clojure">(-&gt; db-request first first) =&gt; {:kind :fact
                               :name &quot;test/tweeted&quot;
                               :key &quot;bob&quot;}</code></pre></div><div class="code"><pre><code class="clojure">(def reply-chan (-&gt; db-request first second))</code></pre></div><div><p>Now the database replies fact events.</p></div><div class="code"><pre><code class="clojure">(async/&gt;!! reply-chan (event :fact &quot;test/tweeted&quot; &quot;bob&quot; [&quot;hello&quot;]))
(async/&gt;!! reply-chan (event :fact &quot;test/tweeted&quot; &quot;bob&quot; [&quot;world&quot;]))
(async/close! reply-chan)</code></pre></div><div><p>The results are emitted on the <code>res-chan</code>:</p></div><div class="code"><pre><code class="clojure">(async/alts!! [res-chan
              (async/timeout 100)]) =&gt; [(event :fact &quot;cloudlog-events.core_test/timeline&quot; &quot;alice&quot; [&quot;hello&quot;]) res-chan]
 (async/alts!! [res-chan
              (async/timeout 100)]) =&gt; [(event :fact &quot;cloudlog-events.core_test/timeline&quot; &quot;alice&quot; [&quot;world&quot;]) res-chan]
 (async/alts!! [res-chan
              (async/timeout 100)]) =&gt; [nil res-chan]</code></pre></div>
        </div>
      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

  </body>

  <script>
  if (false) {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', '<@=tracking>', 'caudate.me');
    ga('send', 'pageview');
  }
  </script>
  
  <script type="text/javascript">
    smoothScroll.init();
    gumshoe.init({});
  
    hljs.registerLanguage("clojure",function(e){var t={"builtin-name":"def defonce cond apply if-not if-let if not not= = < > <= >= == + / * - rem quot neg? pos? delay? symbol? keyword? true? false? integer? empty? coll? list? set? ifn? fn? associative? sequential? sorted? counted? reversible? number? decimal? class? distinct? isa? float? rational? reduced? ratio? odd? even? char? seq? vector? string? map? nil? contains? zero? instance? not-every? not-any? libspec? -> ->> .. . inc compare do dotimes mapcat take remove take-while drop letfn drop-last take-last drop-while while intern condp case reduced cycle split-at split-with repeat replicate iterate range merge zipmap declare line-seq sort comparator sort-by dorun doall nthnext nthrest partition eval doseq await await-for let agent atom send send-off release-pending-sends add-watch mapv filterv remove-watch agent-error restart-agent set-error-handler error-handler set-error-mode! error-mode shutdown-agents quote var fn loop recur throw try monitor-enter monitor-exit defmacro defn defn- macroexpand macroexpand-1 for dosync and or when when-not when-let comp juxt partial sequence memoize constantly complement identity assert peek pop doto proxy defstruct first rest cons defprotocol cast coll deftype defrecord last butlast sigs reify second ffirst fnext nfirst nnext defmulti defmethod meta with-meta ns in-ns create-ns import refer keys select-keys vals key val rseq name namespace promise into transient persistent! conj! assoc! dissoc! pop! disj! use class type num float double short byte boolean bigint biginteger bigdec print-method print-dup throw-if printf format load compile get-in update-in pr pr-on newline flush read slurp read-line subvec with-open memfn time re-find re-groups rand-int rand mod locking assert-valid-fdecl alias resolve ref deref refset swap! reset! set-validator! compare-and-set! alter-meta! reset-meta! commute get-validator alter ref-set ref-history-count ref-min-history ref-max-history ensure sync io! new next conj set! to-array future future-call into-array aset gen-class reduce map filter find empty hash-map hash-set sorted-map sorted-map-by sorted-set sorted-set-by vec vector seq flatten reverse assoc dissoc list disj get union difference intersection extend extend-type extend-protocol int nth delay count concat chunk chunk-buffer chunk-append chunk-first chunk-rest max min dec unchecked-inc-int unchecked-inc unchecked-dec-inc unchecked-dec unchecked-negate unchecked-add-int unchecked-add unchecked-subtract-int unchecked-subtract chunk-next chunk-cons chunked-seq? prn vary-meta lazy-seq spread list* str find-keyword keyword symbol gensym force rationalize"},r="a-zA-Z_\\-!.?+*=<>&#'",n="["+r+"]["+r+"0-9/;:]*",a="[-+]?\\d+(\\.\\d+)?",o={b:n,r:0},s={cN:"number",b:a,r:0},i=e.inherit(e.QSM,{i:null}),c=e.C(";","$",{r:0}),d={cN:"literal",b:/\b(true|false|nil)\b/},l={b:"[\\[\\{]",e:"[\\]\\}]"},m={cN:"comment",b:"\\^"+n},p=e.C("\\^\\{","\\}"),u={cN:"symbol",b:"[:]{1,2}"+n},f={b:"\\(",e:"\\)"},h={eW:!0,r:0},y={k:t,l:n,cN:"name",b:n,starts:h},b=[f,i,m,p,c,u,l,s,d,o];return f.c=[e.C("comment",""),y,h],h.c=b,l.c=b,{aliases:["clj"],i:/\S/,c:[f,i,m,p,c,u,l,s,d]}});
    hljs.initHighlightingOnLoad();
  </script>
</html>
