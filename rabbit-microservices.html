
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <link rel="shortcut icon" href="favicon.ico">
  <title>axiom//rabbit-microservices.core - A Microservices Framwork Based on RabbitMQ</title>
  <script src="js/highlight.min.js"></script>
  <script src="js/gumshoe.min.js"></script>
  <script src="js/smooth-scroll.min.js"></script>
  
  <!-- CSS -->
  <link rel="stylesheet" href="css/poole.css">
  <link rel="stylesheet" href="css/syntax.css">
  <link rel="stylesheet" href="css/lanyon.css">
  <link rel="stylesheet" href="css/bolton.css">
  <link rel="stylesheet" href="css/bolton-api.css">
  <link rel="stylesheet" href="css/bolton-highlight.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">
  
</head>

  <body class="theme-base-08">
    <span id="page-top"></span>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <nav class="sidebar-nav">
    <span>&nbsp;</span>
    <a class="sidebar-nav-item header" href="index.html"><img src="img/logo-white.png"/></a>
    <span>&nbsp;</span>
    <a class="sidebar-nav-item" href="axiom-clj.html">axiom-clj.core</a><a class="sidebar-nav-item" href="cloudlog.html">cloudlog.core</a><a class="sidebar-nav-item" href="cloudlog-events.html">cloudlog-events.core</a><a class="sidebar-nav-item" href="cloudlog.graph.html">cloudlog.graph</a><a class="sidebar-nav-item" href="cloudlog.interset.html">cloudlog.interset</a><a class="sidebar-nav-item" href="di.html">di.core</a><a class="sidebar-nav-item" href="docs.html"></a><a class="sidebar-nav-item" href="dynamo.html">dynamo.core</a><a class="sidebar-nav-item" href="gateway.html">gateway.core</a><a class="sidebar-nav-item" href="migrator.html">migrator.core</a><a class="sidebar-nav-item" href="permacode.html">permacode.core</a><a class="sidebar-nav-item" href="permacode.hasher.html">permacode.hasher</a><a class="sidebar-nav-item" href="permacode.publish.html">permacode.publish</a><a class="sidebar-nav-item" href="permacode.symbols.html">permacode.symbols</a><a class="sidebar-nav-item" href="permacode.validate.html">permacode.validate</a><a class="sidebar-nav-item active" href="rabbit-microservices.html">rabbit-microservices.core</a><a class="sidebar-nav-item" href="s3.html">s3.core</a><a class="sidebar-nav-item" href="storm.html">storm.core</a><a class="sidebar-nav-item" href="zk-plan.html">zk-plan.core</a>
    <span class="sidebar-nav-item">&nbsp;</span>
    <span class="sidebar-nav-item">&nbsp;</span>
  </nav>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
	  <a href="index.html"><img src="img/axiom-logo.png"></a>
          <h3 class="masthead-title">
            <span>axiom//rabbit-microservices.core</span>
            <small>A Microservices Framwork Based on RabbitMQ</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="page">
          <div class="heading">
            <div>
              <h5>Author: Boaz Rosenan&nbsp;&nbsp;<a href="mailto:brosenan@gmail.com">(brosenan@gmail.com)</a></h5>
              <h5>Date: 06 July 2017</h5>
              <h5>Repository: <a href="https://github.com/brosenan/axiom">https://github.com/brosenan/axiom</a></h5>
              <h5>Version: 0.1.0-SNAPSHOT</h5></div></div>
          <hr/>
          <div class="outline">
            <div class="toc">
              <nav data-gumshoe-header>
                <ul data-gumshoe>
                  <a data-scroll class="top" href="#page-top">rabbit-microservices.core</a>
                  <li><a class="chapter" data-scroll="" href="#introduction"><h4>1 &nbsp; Introduction</h4></a></li><li><a class="chapter" data-scroll="" href="#serve"><h4>2 &nbsp; serve: Register an Event Handler</h4></a></li><li><a class="chapter" data-scroll="" href="#declare-service"><h4>3 &nbsp; declare-service: Declare an AMQP Queue</h4></a><a class="section" data-scroll="" href="#declare-volatile-service"><h5><i>3.1 &nbsp; declare-volatile-service</i></h5></a></li><li><a class="chapter" data-scroll="" href="#assign-service"><h4>4 &nbsp; assign-service: Register an Event Handler</h4></a></li><li><a class="chapter" data-scroll="" href="#publish"><h4>5 &nbsp; publish: Publish an Event from the Outside</h4></a></li><li><a class="chapter" data-scroll="" href="#poll-events"><h4>6 &nbsp; poll-events: Pull Mode</h4></a></li><li><a class="chapter" data-scroll="" href="#event-bridge"><h4>7 &nbsp; event-bridge</h4></a></li><li><a class="chapter" data-scroll="" href="#usage-example"><h4>8 &nbsp; Usage Example</h4></a></li><li><a class="chapter" data-scroll="" href="#under-the-hood"><h4>9 &nbsp; Under the Hood</h4></a><a class="section" data-scroll="" href="#rabbitmq-service"><h5><i>9.1 &nbsp; rabbitmq-service</i></h5></a><a class="section" data-scroll="" href="#event-routing-key"><h5><i>9.2 &nbsp; event-routing-key</i></h5></a><a class="section" data-scroll="" href="#handle-event"><h5><i>9.3 &nbsp; handle-event</i></h5></a><a class="section" data-scroll="" href="#declare-private-queue"><h5><i>9.4 &nbsp; declare-private-queue</i></h5></a><a class="section" data-scroll="" href="#delete-queue"><h5><i>9.5 &nbsp; delete-queue</i></h5></a><a class="section" data-scroll="" href="#register-events-to-queue"><h5><i>9.6 &nbsp; register-events-to-queue</i></h5></a></li>
                </ul>
              </nav>
            </div>
          </div>

          <div class="toc">
              <nav>
                <ul>
                  <li><a class="chapter" data-scroll="" href="#introduction"><h4>1 &nbsp; Introduction</h4></a></li><li><a class="chapter" data-scroll="" href="#serve"><h4>2 &nbsp; serve: Register an Event Handler</h4></a></li><li><a class="chapter" data-scroll="" href="#declare-service"><h4>3 &nbsp; declare-service: Declare an AMQP Queue</h4></a><a class="section" data-scroll="" href="#declare-volatile-service"><h5><i>3.1 &nbsp; declare-volatile-service</i></h5></a></li><li><a class="chapter" data-scroll="" href="#assign-service"><h4>4 &nbsp; assign-service: Register an Event Handler</h4></a></li><li><a class="chapter" data-scroll="" href="#publish"><h4>5 &nbsp; publish: Publish an Event from the Outside</h4></a></li><li><a class="chapter" data-scroll="" href="#poll-events"><h4>6 &nbsp; poll-events: Pull Mode</h4></a></li><li><a class="chapter" data-scroll="" href="#event-bridge"><h4>7 &nbsp; event-bridge</h4></a></li><li><a class="chapter" data-scroll="" href="#usage-example"><h4>8 &nbsp; Usage Example</h4></a></li><li><a class="chapter" data-scroll="" href="#under-the-hood"><h4>9 &nbsp; Under the Hood</h4></a><a class="section" data-scroll="" href="#rabbitmq-service"><h5><i>9.1 &nbsp; rabbitmq-service</i></h5></a><a class="section" data-scroll="" href="#event-routing-key"><h5><i>9.2 &nbsp; event-routing-key</i></h5></a><a class="section" data-scroll="" href="#handle-event"><h5><i>9.3 &nbsp; handle-event</i></h5></a><a class="section" data-scroll="" href="#declare-private-queue"><h5><i>9.4 &nbsp; declare-private-queue</i></h5></a><a class="section" data-scroll="" href="#delete-queue"><h5><i>9.5 &nbsp; delete-queue</i></h5></a><a class="section" data-scroll="" href="#register-events-to-queue"><h5><i>9.6 &nbsp; register-events-to-queue</i></h5></a></li>
                </ul>
              </nav>
          </div>
          <div><span id="introduction"></span><h2><b>1 &nbsp;&nbsp; Introduction</b></h2></div><div><p><code>rabbit-microservices</code> is a library that supports the definition of microservices. It <a href='di.html#provide'>provides</a> the <code>serve</code> function as a <a href='di.html'>resource</a>. In turn, the <code>serve</code> function registers given functions to a subset of the events published through AMQP. It is provided a partial event, and calls the given function on any event that matches the given partial event.</p></div><div><p>The event structure we refer to here is the one discussed in <a href='cloudlog-events.html'>cloudlog-events</a>.</p></div><div><span id="serve"></span><h2><b>2 &nbsp;&nbsp; serve: Register an Event Handler</b></h2></div><div><p><code>serve</code> is a <a href='di.html'>dependency-injection resource</a> which depends on two functions:</p><ol><li><a href='#declare-service'>declare-service</a>, and</li><li><a href='#assign-service'>assign-service</a></li></ol></div><div><p>We will consider the following service function for the examples below:</p></div><div class="code"><pre><code class="clojure">(defn my-service [ev])</code></pre></div><div><p>It takes a service function and a partial event, and does the following:</p><ol><li>Based on the name of the function, it creates a queue name and calls <code>declare-service</code> to declare it.</li><li>It then assigns the function to the service by calling <code>assign-service</code>.</li></ol></div><div class="code"><pre><code class="clojure">(let [calls (transient [])
     $ (di/injector {:declare-service (fn [key reg] (conj! calls [:declare-service key reg]))
                     :assign-service (fn [key func] (conj! calls [:assign-service key func]))})]
 (module $)
 (di/startup $)
 (di/do-with! $ [serve]
   (serve my-service {:partial :event}) =&gt; nil
   (persistent! calls)
   =&gt; [[:declare-service &quot;rabbit-microservices.core-test/my-service&quot; {:partial :event}]
       [:assign-service &quot;rabbit-microservices.core-test/my-service&quot; my-service]]))</code></pre></div><div><span id="declare-service"></span><h2><b>3 &nbsp;&nbsp; declare-service: Declare an AMQP Queue</b></h2></div><div><p><code>declare-service</code> depends on an <code>rabbitmq-service</code> resource (which itself depends on <code>rabbitmq-config</code>).</p></div><div class="code"><pre><code class="clojure">(let [$ (di/injector {:rabbitmq-service {:chan :some-chan}})]
 (module $)
 (di/startup $)
 (def declare-service (di/do-with! $ [declare-service] declare-service)))</code></pre></div><div><p><code>declare-service</code> declares a queue and binds it to the <code>facts</code> exchange to receive events matching the given partial event.</p></div><div class="code"><pre><code class="clojure">(declare-service &quot;foobar&quot; {:kind :fact
                          :name &quot;foo/bar&quot;}) =&gt; nil
 (provided
(lq/declare :some-chan &quot;foobar&quot; {:durable true}) =&gt; irrelevant
(lq/bind :some-chan &quot;foobar&quot;
         facts-exch {:routing-key &quot;f.17cdeaefa5cc6022481c824e15a47a7726f593dd.#&quot;})
=&gt; irrelevant)</code></pre></div><div><span id="declare-volatile-service"></span><h3>3.1 &nbsp;&nbsp; declare-volatile-service</h3></div><div><p>Sometimes we wish services to exist only temporarily. We set them up for a particular reason, and when that reason no longer exists we have no use for this service. <code>declare-volatile-service</code> creates a non-durable AMQP queue, so it is removed after a broker restart.</p></div><div class="code"><pre><code class="clojure">(let [$ (di/injector {:rabbitmq-service {:chan :some-chan}})]
 (module $)
 (di/startup $)
 (di/do-with! $ [declare-volatile-service]
              (declare-volatile-service &quot;foobar&quot; {:kind :fact
                                                  :name &quot;foo/bar&quot;}) =&gt; nil
              (provided
               (lq/declare :some-chan &quot;foobar&quot; {:durable false}) =&gt; irrelevant
               (lq/bind :some-chan &quot;foobar&quot;
                        facts-exch {:routing-key &quot;f.17cdeaefa5cc6022481c824e15a47a7726f593dd.#&quot;})
               =&gt; irrelevant)))</code></pre></div><div><span id="assign-service"></span><h2><b>4 &nbsp;&nbsp; assign-service: Register an Event Handler</b></h2></div><div><p><code>assign-service</code> depends on an <code>rabbitmq-service</code>.</p></div><div class="code"><pre><code class="clojure">(let [$ (di/injector {:rabbitmq-service {:chan :some-chan}})]
 (module $)
 (di/startup $)
 (def assign-service (di/do-with! $ [assign-service] assign-service)))</code></pre></div><div><p><code>assign-service</code> takes a key that was previously <a href='#declare-service'>declared</a> and a service function, and subscribes to this queue using a function that wraps the given function.</p></div><div class="code"><pre><code class="clojure">(assign-service &quot;foobar&quot; my-service) =&gt; nil
 (provided
(lc/subscribe :some-chan &quot;foobar&quot; irrelevant {:auto-ack true}) =&gt; irrelevant)</code></pre></div><div><p>Auto acknowledgement is disabled when the provided function has three parameters. The third of which is expected to be bound to an explicit <code>ack</code> function.</p></div><div class="code"><pre><code class="clojure">(defn my-other-service [event publish ack])</code></pre></div><div class="code"><pre><code class="clojure">(assign-service &quot;foobar&quot; my-other-service) =&gt; nil
 (provided
(lc/subscribe :some-chan &quot;foobar&quot; irrelevant {:auto-ack false}) =&gt; irrelevant)</code></pre></div><div><p>The <code>lc/subscribe</code> function is given a closure returned by <a href='#handle-event'>handle-event</a>. Please refer to it for more information.</p></div><div><span id="publish"></span><h2><b>5 &nbsp;&nbsp; publish: Publish an Event from the Outside</b></h2></div><div><p><code>publish</code> is a service that allows its users to publish events from outside the context of a service. It depends on <code>rabbitmq-service</code>.</p></div><div class="code"><pre><code class="clojure">(let [$ (di/injector {:rabbitmq-service {:chan :some-chan}})]
 (module $)
 (di/startup $)
 (def publish (di/do-with! $ [publish] publish)))</code></pre></div><div class="code"><pre><code class="clojure">(publish ..ev..) =&gt; nil
 (provided
(nippy/freeze ..ev..) =&gt; ..bin..
(event-routing-key ..ev..) =&gt; ..routing-key..
(lb/publish :some-chan facts-exch ..routing-key.. ..bin.. {}) =&gt; irrelevant)</code></pre></div><div><span id="poll-events"></span><h2><b>6 &nbsp;&nbsp; poll-events: Pull Mode</b></h2></div><div><p>The most efficient and conveinent way to receive messages from a queue is in <em>push mode</em>, where the AMQP broker has control. In this approach (as implemented by <a href='#assign-service'>assign-service</a>), we implement a function that is called whenever a new event arrives.</p></div><div><p>However, sometimes we need to work the other way. We need to have control, and consume messages off a queue when <em>we</em> decide to do so.</p></div><div><p>An example for such a situation is where we respond to a user request. In such a case, without the user request we have nothing to do with the data,  so it does not make sense to have a service function handling all messages. When a user request comes in, we wish to read all messages currently on the queue and return them to the user. This is exactly what the <code>poll-events</code> function does.</p></div><div><p><code>poll-events</code> is a DI resource which is based on <code>rabbitmq-service</code>.</p></div><div class="code"><pre><code class="clojure">(let [$ (di/injector {:rabbitmq-service {:chan :some-chan}})]
 (module $)
 (di/startup $)
 (di/do-with! $ [poll-events]
              (def poll-events poll-events)))</code></pre></div><div><p>When called, it calls <a href='http://reference.clojurerabbitmq.info/langohr.basic.html#var-get'>lb/get</a> to read events off the given queue. It reads all events until the queue is empty. Events are auto-acknowledged.</p></div><div class="code"><pre><code class="clojure">(poll-events ..queue..) =&gt; [..ev1.. ..ev2..]
 (provided
(lb/get :some-chan ..queue.. true) =streams=&gt; [[..metadata.. ..payload1..]
                                               [..metadata.. ..payload2..]
                                               nil]
(nippy/thaw ..payload1..) =&gt; ..ev1..
(nippy/thaw ..payload2..) =&gt; ..ev2..)</code></pre></div><div><span id="event-bridge"></span><h2><b>7 &nbsp;&nbsp; event-bridge</b></h2></div><div><p>An <code>event-bridge</code> is a bidirectional bridge between events flowing globally through Axiom (as AMQP messages), and local events flowing through <code>core.async</code> channels. It is intended to connect Axiom (the server) to an external client.</p></div><div><p>It takes a pair of channels named <code>c2s</code> (client to server) and <code>s2c</code> (server to client). It does the following:</p><ol><li><a href='#publish'>publish</a> <code>:fact</code> events flowing on the <code>c2s</code> channel.</li><li>Handle <code>:reg</code> events by registering to <code>:fact</code> events they refer to, and</li><li>Push all registered events to the <code>s2c</code> channel.</li></ol></div><div><p><code>event-bridge</code> is a DI resource with the following dependencies:</p><ol><li><a href='#publish'>publish</a>, used to publish events coming on <code>c2s</code>.</li><li><a href='#declare-private-queue'>declare-private-queue</a>, used to create a private queue for this session.</li><li><a href='#assign-service'>assign-service</a>, used to assign a function that will push incoming events to the <code>s2c</code> channel.</li><li><code>database-chan</code> (e.g., <a href='dynamo.html#database-chan'>this</a>), to retrieve any existing events, if so requested during registration.</li><li><a href='#register-events-to-queue'>register-events-to-queue</a>, used to direct events of interest to the session's queue, and</li><li><a href='#delete-queue'>delete-queue</a>, used to close the session queue once the <code>c2s</code> channel closes.</li></ol></div><div class="code"><pre><code class="clojure">(def calls (async/chan 10))
 (defn get-call []
 (let [[call chan] (async/alts!! [calls
                                  (async/timeout 1000)])]
   (when (not= chan calls)
     (throw (Exception. &quot;Timed out waiting to read call&quot;)))
   call))
 (def database-chan (async/chan 10))
 
 (let [$ (di/injector {:publish
                     (fn [ev] (async/&gt;!! calls [:publish ev]))
                     :declare-private-queue
                     (fn [] (async/&gt;!! calls [:declare-private-queue])
                       &quot;some-random-queue&quot;)
                     :assign-service
                     (fn [queue func] (async/&gt;!! calls [:assign-service queue func]))
                     :database-chan
                     database-chan
                     :register-events-to-queue
                     (fn [queue reg] (async/&gt;!! calls [:register-events-to-queue queue reg]))
                     :delete-queue
                     (fn [queue] (async/&gt;!! calls [:delete-queue queue]))})]
 (module $)
 (di/startup $)
 (di/do-with! $ [event-bridge]
              (def event-bridge event-bridge)))</code></pre></div><div><p>To create a session, <code>event-bridge</code> is called with a pair <code>&#91;c2s s2c&#93;</code> of channels.</p></div><div class="code"><pre><code class="clojure">(def chan-pair [(async/chan 100) (async/chan 100)])
 (event-bridge chan-pair) =&gt; nil</code></pre></div><div><p>The first thing <code>event-bridge</code> does is declare a private queue, and assigns a handler to it.</p></div><div class="code"><pre><code class="clojure">(get-call) =&gt; [:declare-private-queue]
 (let [[assign queue func] (get-call)]
 assign =&gt; :assign-service
 queue =&gt; &quot;some-random-queue&quot;
 (def incoming-handler func))</code></pre></div><div><p>Pushing a <code>:fact</code> event to the <code>c2s</code> channel will cause it to be published.</p></div><div class="code"><pre><code class="clojure">(let [[c2s s2c] chan-pair]
 (async/&gt;!! c2s {:kind :fact
                 :name &quot;foo&quot;
                 :key &quot;bar&quot;
                 :data [1 2]})
 (async/&gt;!! c2s {:kind :fact
                 :name &quot;foo&quot;
                 :key &quot;baz&quot;
                 :data [2 3]})
 (get-call) =&gt; [:publish {:kind :fact
                          :name &quot;foo&quot;
                          :key &quot;bar&quot;
                          :data [1 2]}]
 (get-call) =&gt; [:publish {:kind :fact
                          :name &quot;foo&quot;
                          :key &quot;baz&quot;
                          :data [2 3]}])</code></pre></div><div><p>Pushing a <code>:reg</code> event will cause it to register to a corresponding <code>:fact</code> event.</p></div><div class="code"><pre><code class="clojure">(let [[c2s s2c] chan-pair]
 (async/&gt;!! c2s {:kind :reg
                 :name &quot;x&quot;
                 :key &quot;y&quot;})
 (get-call) =&gt; [:register-events-to-queue &quot;some-random-queue&quot; {:kind :fact
                                                               :name &quot;x&quot;
                                                               :key &quot;y&quot;}])</code></pre></div><div><p>When an event is received, it is pushed to the <code>s2c</code> channel.</p></div><div class="code"><pre><code class="clojure">(let [[c2s s2c] chan-pair]
 (incoming-handler {:kind :fact
                    :name &quot;boo&quot;
                    :key &quot;tar&quot;
                    :data [1 2]})
 (let [[pushed chan] (async/alts!! [s2c
                                    (async/timeout 1000)])]
   chan =&gt; s2c
   pushed =&gt; {:kind :fact
              :name &quot;boo&quot;
              :key &quot;tar&quot;
              :data [1 2]}))</code></pre></div><div><p>A <code>:reg</code> event may contain a <code>:get-existing</code> field. If such a field exists and is <code>true</code>, a request is made to the database (through <code>database-chan</code>) to retrieve all existing events matching the registration.</p></div><div class="code"><pre><code class="clojure">(let [[c2s s2c] chan-pair]
 (async/&gt;!! c2s {:kind :reg
                 :name &quot;x&quot;
                 :key &quot;y&quot;
                 :get-existing true})
 ;; Registration is the same
 (get-call) =&gt; [:register-events-to-queue &quot;some-random-queue&quot; {:kind :fact
                                                               :name &quot;x&quot;
                                                               :key &quot;y&quot;}]
 (let [[[query reply-chan] chan] (async/alts!! [database-chan
                                                (async/timeout 1000)])]
   chan =&gt; database-chan
   (def reply-chan reply-chan)))</code></pre></div><div><p>Results returned from the database are pushed to the <code>s2c</code> channel.</p></div><div class="code"><pre><code class="clojure">(let [[c2s s2c] chan-pair]
 (async/&gt;!! reply-chan {:kind :fact
                        :name &quot;some&quot;
                        :key &quot;event&quot;
                        :data [1 2 3]})
 (async/&gt;!! reply-chan {:kind :fact
                        :name &quot;some&quot;
                        :key &quot;other event&quot;
                        :data [2 3 4]})
 (async/close! reply-chan)
 (let [[ev chan] (async/alts!! [s2c
                                (async/timeout 1000)])]
   chan =&gt; s2c
   ev =&gt; {:kind :fact
          :name &quot;some&quot;
          :key &quot;event&quot;
          :data [1 2 3]})
 (let [[ev chan] (async/alts!! [s2c
                                (async/timeout 1000)])]
   chan =&gt; s2c
   ev =&gt; {:kind :fact
          :name &quot;some&quot;
          :key &quot;other event&quot;
          :data [2 3 4]}))</code></pre></div><div><p>When the <code>c2s</code> channel is closed, <code>event-bridge</code> deletes its queue.</p></div><div class="code"><pre><code class="clojure">(let [[c2s s2c] chan-pair]
 (async/close! c2s)
 (get-call) =&gt; [:delete-queue &quot;some-random-queue&quot;])</code></pre></div><div><span id="usage-example"></span><h2><b>8 &nbsp;&nbsp; Usage Example</b></h2></div><div><p>To demonstrate how the above functions work together we build a small usage example.</p></div><div><p>In our example we have the following service functions:</p><ol><li>Function <code>sum-foo</code> that sums the values in the data of events of name "foo" and emits events named "foo-sum".</li><li>Function <code>count-ev</code> that counts the events of the different names and emits events of type "count" (it does not count "count" events).</li><li>Function <code>foo-from-count</code> that listens on "count" events and emits corresponding "foo" events with the same value.</li></ol></div><div class="code"><pre><code class="clojure">:integ ; Integration test.  Does not run during continouts integration
 (def foo-sum (atom 0))
 (def ev-count (atom {}))
 (def $ (di/injector))
 (module $)
 (di/do-with $ [serve]
 (println &quot;Registering services&quot;)
 (serve (fn ;; sum-foo
          [ev pub]
          (swap! foo-sum (partial + (:data ev)))
          (pub {:kind :fact
                :name &quot;foo-sum&quot;
                :key 0
                :data @foo-sum}))
        {:kind :fact
         :name &quot;foo&quot;})

 (serve (fn  ;; count-ev
          [ev pub]
          (let [key (:name ev)]
            (swap! ev-count (fn [m]
                              (let [old (or (m key) 0)
                                    new (inc old)]
                                (assoc m key new))))
            (pub {:kind :fact
                  :name &quot;count&quot;
                  :key key
                  :data (@ev-count key)})))
        {:kind :fact})

 (serve (fn ;; foo-from-count
          [ev pub]
          (pub {:kind :fact
                :name &quot;foo&quot;
                :key (:key ev)
                :data (:data ev)}))
        {:kind :fact
         :name &quot;count&quot;}))</code></pre></div><div><p>For the <code>serve</code> resource to initialize, we need to provide an <code>rabbitmq-config</code> resource with values needed for the underlying <code>langohr</code> library to find the AMQP broker. We will use the default values.</p></div><div class="code"><pre><code class="clojure">:integ
 (di/provide $ rabbitmq-config []
           rmq/*default-config*)
 (di/startup $)</code></pre></div><div><p>Now our service is ready to roll.<br /> All we need is to get the fire started is a little match &ndash; a single event.</p></div><div class="code"><pre><code class="clojure">:integ ; Integration test.  Does not run during continouts integration
    (di/do-with! $ [publish]
                 (println &quot;Kicking the first event&quot;)
                 (publish {:kind :fact
                           :name &quot;foo&quot;
                           :key 0
                           :data 1}))
    (println &quot;waiting for the sum to reach ten-milion&quot;)
    (while (&lt; @foo-sum 10000000)
      (Thread/sleep 100))
    (println &quot;done!&quot;)</code></pre></div><div><span id="under-the-hood"></span><h2><b>9 &nbsp;&nbsp; Under the Hood</b></h2></div><div><span id="rabbitmq-service"></span><h3>9.1 &nbsp;&nbsp; rabbitmq-service</h3></div><div><p><code>rabbitmq-service</code> is a DI resource that represents a running RabbitMQ broker. It is a map containing the following properties:</p><ul><li><code>:conn</code> &ndash; a connection object to a server.</li><li><code>:chan</code> &ndash; an open channel.</li><li><code>:alive</code> &ndash; an atom holding a Boolean value used for shutting down the conection.</li></ul></div><div><p>Initialization also declares the <code>facts</code> exchange, which is a topic-based AMQP exchange.</p></div><div class="code"><pre><code class="clojure">(let [$ (di/injector {:rabbitmq-config rmq/*default-config*})]
 (module $)
 (di/startup $)
 (di/do-with! $ [rabbitmq-service]
              [(:conn rabbitmq-service)
               (:chan rabbitmq-service)
               @(:alive rabbitmq-service)])) =&gt; [..conn.. ..chan.. true]
 (provided
(rmq/connect) =&gt; ..conn..
(lch/open ..conn..) =&gt; ..chan..
(le/declare ..chan.. facts-exch &quot;topic&quot;) =&gt; irrelevant)</code></pre></div><div><p>The dynamic variable <code>langohr.core/&#42;default-config&#42;</code> controls the configuration.  See the <a href='http://clojurerabbitmq.info'>Langohr documentation</a> for more information.</p></div><div><span id="event-routing-key"></span><h3>9.2 &nbsp;&nbsp; event-routing-key</h3></div><div><p>The <code>event-routing-key</code> function returns a AMQP-conforming routing key for a given event map.</p></div><div class="code"><pre><code class="clojure">(event-routing-key {:kind :fact
                   :name &quot;foo/bar&quot;
                   :key 1234
                   :ts 1000
                   :data [&quot;foo&quot; :bar]
                   :change 1
                   :writers #{}
                   :readers #{}}) =&gt; &quot;f.17cdeaefa5cc6022481c824e15a47a7726f593dd.7110eda4d09e062aa5e4a390b0a572ac0d2c0220&quot;</code></pre></div><div><p>The initial <code>f</code> is derived from <code>:kind :fact</code>.  For <code>:kind :rule</code> an exception is thrown.</p></div><div class="code"><pre><code class="clojure">(event-routing-key {:kind :rule
                   :name &quot;foo/bar&quot;
                   :key 1234
                   :ts 1000
                   :data [&quot;foo&quot; :bar]
                   :change 1
                   :writers #{}
                   :readers #{}}) =&gt; (throws &quot;Only fact events are supported&quot;)</code></pre></div><div><p>The ony fields that effect the routing key are <code>kind</code>, <code>name</code> and <code>key</code>.</p></div><div class="code"><pre><code class="clojure">(let [base  (event-routing-key {:kind :fact
                                    :name &quot;foo/bar&quot;
                                    :key 1234
                                    :ts 1000
                                    :data [&quot;foo&quot; :bar]
                                    :change 1
                                    :writers #{}
                                    :readers #{}})]
      (= (event-routing-key {:kind :fact
                             :name &quot;foo/bar&quot;
                             :key 1234
                             :ts 1001
                             :data [&quot;fool&quot; :baz]
                             :change -1
                             :writers #{:me}
                             :readers #{:you}}) base) =&gt; true
      (= (event-routing-key {:kind :fact
                             :name &quot;foo/baz&quot; ; Different name
                             :key 1234
                             :ts 1001
                             :data [&quot;fool&quot; :baz]
                             :change -1
                             :writers #{:me}
                             :readers #{:you}}) base) =&gt; false
      (= (event-routing-key {:kind :fact
                             :name &quot;foo/bar&quot;
                             :key [:foo :bar] ; Different key
                             :ts 1001
                             :data [&quot;fool&quot; :baz]
                             :change -1
                             :writers #{:me}
                             :readers #{:you}}) base) =&gt; false)</code></pre></div><div><p><code>event-routing-key</code> can handle partial events. If <code>:name</code> is omitted, a pattern that matches all facts is returned.</p></div><div class="code"><pre><code class="clojure">(event-routing-key {:kind :fact}) =&gt; &quot;f.#&quot;</code></pre></div><div><p>If <code>:name</code> is provided, but <code>:key</code> is omitted, a pattern matching all keys with that name is returned.</p></div><div class="code"><pre><code class="clojure">(event-routing-key {:kind :fact
                   :name &quot;foo/bar&quot;}) =&gt; #&quot;f&#92;.[0-9a-f]+&#92;.#&quot;</code></pre></div><div><span id="handle-event"></span><h3>9.3 &nbsp;&nbsp; handle-event</h3></div><div><p><code>handle-event</code> takes a function to be called when an event arrives and the <code>:alive</code> atom for the service  along with arguments provided by a subscription to a queue,  so that the function <code>&#40;partial handle-event some-func alive&#41;</code> can be used with <code>lc/subscribe</code>.</p></div><div><p>The wrapped function can take one, two, or three parameters. If it takes one parameter, we pass this parameter a de-serialization of the event.</p></div><div class="code"><pre><code class="clojure">(def alive (atom true))
 (def received (atom '()))
 (defn my-func [ev]
 (swap! received #(conj % ev)))
 (def my-event {:kind :fact
              :name &quot;foo/bar&quot;
              :key 1234
              :ts 1000
              :data [&quot;foo&quot; :bar]
              :change 1
              :writers #{}
              :readers #{}})
 (def my-event-bin (nippy/freeze my-event))
 ; By running handle-event...
 (handle-event my-func alive constantly :the-channel {:delivery-tag 777} my-event-bin) =&gt; nil
 ; we execute my-func, which adds the event to received
 @received =&gt; [my-event]</code></pre></div><div><p>If the wrapped function accepts two parameters, the second parameter is taken to be a <code>publish</code> function, which publishes events on the facts exchange. The event handler (<code>my-func</code> in the example below) does not have to specify all fields in the event it publishes (<code>event2</code> in the example). All fields that are not specified in the event default to their values in the event that triggerred the function (<code>event-that-was-sent</code> in the example).</p></div><div class="code"><pre><code class="clojure">(def event2 {:name &quot;foo/baz&quot;
            :key 5555
            :data [1 2 3 4]})
 (defn my-func [ev publish]
 (publish event2))
 (def event-that-was-sent
 (merge my-event event2))
 (handle-event my-func alive constantly :the-channel :meta-attrs my-event-bin) =&gt; nil
 (provided
(nippy/freeze event-that-was-sent) =&gt; ..bin..
(lb/publish :the-channel facts-exch (event-routing-key event2) ..bin.. :meta-attrs) =&gt; irrelevant)</code></pre></div><div><p>When the <code>alive</code> atom evaluates to <code>false</code>, the publish function does nothing.</p></div><div class="code"><pre><code class="clojure">(reset! alive false)
 (handle-event my-func alive constantly :the-channel :meta-attrs my-event-bin) =&gt; nil
 ; Nothing is published</code></pre></div><div><p>If the wrapped function accepts three parameters, the third parameter is taken to be an <code>ack</code> function, that explicitly acknowledges the received event.</p></div><div class="code"><pre><code class="clojure">(defn my-func [ev publish ack]
 (ack))
 (handle-event my-func alive constantly :the-channel {:delivery-tag &quot;foo&quot;} my-event-bin) =&gt; nil
 (provided
(lb/ack :the-channel &quot;foo&quot;) =&gt; irrelevant)</code></pre></div><div><span id="declare-private-queue"></span><h3>9.4 &nbsp;&nbsp; declare-private-queue</h3></div><div><p><code>declare-private-queue</code> is made to allow the creation of private queues, to be used not for a service, but rather for a specific user session. Unlike <a href='#declare-service'>declare-service</a>, it does not bind an exchange to this queue.</p></div><div><p>It is a DI resource, based on <code>rabbitmq-service</code>.</p></div><div class="code"><pre><code class="clojure">(let [$ (di/injector {:rabbitmq-service {:chan :some-chan}})]
 (module $)
 (di/startup $)
 (di/do-with! $ [declare-private-queue]
              (def declare-private-queue declare-private-queue)))</code></pre></div><div><p>It takes no parameters, and calls <a href='http://reference.clojurerabbitmq.info/langohr.queue.html#var-declare-server-named'>lq/declare-server-named</a> to create a new queue, named by the AMQP broker, exclusive to this connection, non-durable and auto-deletable.</p></div><div class="code"><pre><code class="clojure">(declare-private-queue) =&gt; ..queue..
 (provided
(lq/declare-server-named :some-chan {:exclusive true}) =&gt; ..queue..)</code></pre></div><div><span id="delete-queue"></span><h3>9.5 &nbsp;&nbsp; delete-queue</h3></div><div><p><code>delete-queue</code> deletes a queue of a given name.</p></div><div><p>It is a DI resource that depends on <code>rabbitmq-service</code>.</p></div><div class="code"><pre><code class="clojure">(let [$ (di/injector {:rabbitmq-service {:chan :some-chan}})]
 (module $)
 (di/startup $)
 (di/do-with! $ [delete-queue]
              (def delete-queue delete-queue)))</code></pre></div><div><p>It takes one parameter &ndash; the name of the queue to be deleted, and calls <code>lq/delete</code> with that name.</p></div><div class="code"><pre><code class="clojure">(delete-queue ..queue..) =&gt; nil
 (provided
(lq/delete :some-chan ..queue..) =&gt; irrelevant)</code></pre></div><div><span id="register-events-to-queue"></span><h3>9.6 &nbsp;&nbsp; register-events-to-queue</h3></div><div><p><code>register-events-to-queue</code> takes a queue name and a partial events, and makes sure events matching this partial event are sent to this queue.</p></div><div><p>It is a DI resource based on <code>rabbitmq-service</code>.</p></div><div class="code"><pre><code class="clojure">(let [$ (di/injector {:rabbitmq-service {:chan :some-chan}})]
 (module $)
 (di/startup $)
 (di/do-with! $ [register-events-to-queue]
              (def register-events-to-queue register-events-to-queue)))</code></pre></div><div><p>When called, it calls <a href='#event-routing-key'>event-routing-key</a> to convert the given partial event to an AMQP routing key. Then it calls <a href='http://reference.clojurerabbitmq.info/langohr.queue.html#var-bind'>lq/bind</a> to make sure matching events are placed in the given queue.</p></div><div class="code"><pre><code class="clojure">(register-events-to-queue ..queue.. ..partial..) =&gt; nil
 (provided
(event-routing-key ..partial..) =&gt; ..routing-key..
(lq/bind :some-chan ..queue.. facts-exch {:routing-key ..routing-key..}) =&gt; irrelevant)</code></pre></div>
        </div>
      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>
  </body>

  <script>
  if (false) {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', '<@=tracking>', 'caudate.me');
    ga('send', 'pageview');
  }
  </script>
  
  <script type="text/javascript">
    smoothScroll.init();
    gumshoe.init({});
  
    hljs.registerLanguage("clojure",function(e){var t={"builtin-name":"def defonce cond apply if-not if-let if not not= = < > <= >= == + / * - rem quot neg? pos? delay? symbol? keyword? true? false? integer? empty? coll? list? set? ifn? fn? associative? sequential? sorted? counted? reversible? number? decimal? class? distinct? isa? float? rational? reduced? ratio? odd? even? char? seq? vector? string? map? nil? contains? zero? instance? not-every? not-any? libspec? -> ->> .. . inc compare do dotimes mapcat take remove take-while drop letfn drop-last take-last drop-while while intern condp case reduced cycle split-at split-with repeat replicate iterate range merge zipmap declare line-seq sort comparator sort-by dorun doall nthnext nthrest partition eval doseq await await-for let agent atom send send-off release-pending-sends add-watch mapv filterv remove-watch agent-error restart-agent set-error-handler error-handler set-error-mode! error-mode shutdown-agents quote var fn loop recur throw try monitor-enter monitor-exit defmacro defn defn- macroexpand macroexpand-1 for dosync and or when when-not when-let comp juxt partial sequence memoize constantly complement identity assert peek pop doto proxy defstruct first rest cons defprotocol cast coll deftype defrecord last butlast sigs reify second ffirst fnext nfirst nnext defmulti defmethod meta with-meta ns in-ns create-ns import refer keys select-keys vals key val rseq name namespace promise into transient persistent! conj! assoc! dissoc! pop! disj! use class type num float double short byte boolean bigint biginteger bigdec print-method print-dup throw-if printf format load compile get-in update-in pr pr-on newline flush read slurp read-line subvec with-open memfn time re-find re-groups rand-int rand mod locking assert-valid-fdecl alias resolve ref deref refset swap! reset! set-validator! compare-and-set! alter-meta! reset-meta! commute get-validator alter ref-set ref-history-count ref-min-history ref-max-history ensure sync io! new next conj set! to-array future future-call into-array aset gen-class reduce map filter find empty hash-map hash-set sorted-map sorted-map-by sorted-set sorted-set-by vec vector seq flatten reverse assoc dissoc list disj get union difference intersection extend extend-type extend-protocol int nth delay count concat chunk chunk-buffer chunk-append chunk-first chunk-rest max min dec unchecked-inc-int unchecked-inc unchecked-dec-inc unchecked-dec unchecked-negate unchecked-add-int unchecked-add unchecked-subtract-int unchecked-subtract chunk-next chunk-cons chunked-seq? prn vary-meta lazy-seq spread list* str find-keyword keyword symbol gensym force rationalize"},r="a-zA-Z_\\-!.?+*=<>&#'",n="["+r+"]["+r+"0-9/;:]*",a="[-+]?\\d+(\\.\\d+)?",o={b:n,r:0},s={cN:"number",b:a,r:0},i=e.inherit(e.QSM,{i:null}),c=e.C(";","$",{r:0}),d={cN:"literal",b:/\b(true|false|nil)\b/},l={b:"[\\[\\{]",e:"[\\]\\}]"},m={cN:"comment",b:"\\^"+n},p=e.C("\\^\\{","\\}"),u={cN:"symbol",b:"[:]{1,2}"+n},f={b:"\\(",e:"\\)"},h={eW:!0,r:0},y={k:t,l:n,cN:"name",b:n,starts:h},b=[f,i,m,p,c,u,l,s,d,o];return f.c=[e.C("comment",""),y,h],h.c=b,l.c=b,{aliases:["clj"],i:/\S/,c:[f,i,m,p,c,u,l,s,d]}});
    hljs.initHighlightingOnLoad();
  </script>
</html>
