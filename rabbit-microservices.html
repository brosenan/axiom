
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <link rel="shortcut icon" href="favicon.ico">
  <title>axiom//rabbit-microservices.core - A Microservices Framwork Based on RabbitMQ</title>
  <script src="js/highlight.min.js"></script>
  <script src="js/gumshoe.min.js"></script>
  <script src="js/smooth-scroll.min.js"></script>
  
  <!-- CSS -->
  <link rel="stylesheet" href="css/poole.css">
  <link rel="stylesheet" href="css/syntax.css">
  <link rel="stylesheet" href="css/lanyon.css">
  <link rel="stylesheet" href="css/bolton.css">
  <link rel="stylesheet" href="css/bolton-api.css">
  <link rel="stylesheet" href="css/bolton-highlight.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">
  
</head>

  <body class="theme-base-08">
    <span id="page-top"></span>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <nav class="sidebar-nav">
    <span>&nbsp;</span>
    <a class="sidebar-nav-item header" href="index.html"><img src="img/logo-white.png"/></a>
    <span>&nbsp;</span>
    <a class="sidebar-nav-item" href="cloudlog.html">cloudlog.core</a><a class="sidebar-nav-item" href="cloudlog-events.html">cloudlog-events.core</a><a class="sidebar-nav-item" href="cloudlog.graph.html">cloudlog.graph</a><a class="sidebar-nav-item" href="cloudlog.interset.html">cloudlog.interset</a><a class="sidebar-nav-item" href="di.html">di.core</a><a class="sidebar-nav-item" href="docs.html"></a><a class="sidebar-nav-item" href="dynamo.html">dynamo.core</a><a class="sidebar-nav-item" href="migrator.html">migrator.core</a><a class="sidebar-nav-item" href="permacode.html">permacode.core</a><a class="sidebar-nav-item" href="permacode.hasher.html">permacode.hasher</a><a class="sidebar-nav-item" href="permacode.publish.html">permacode.publish</a><a class="sidebar-nav-item" href="permacode.symbols.html">permacode.symbols</a><a class="sidebar-nav-item" href="permacode.validate.html">permacode.validate</a><a class="sidebar-nav-item active" href="rabbit-microservices.html">rabbit-microservices.core</a><a class="sidebar-nav-item" href="s3.html">s3.core</a><a class="sidebar-nav-item" href="zk-plan.html">zk-plan.core</a>
    <span class="sidebar-nav-item">&nbsp;</span>
    <span class="sidebar-nav-item">&nbsp;</span>
  </nav>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
	  <a href="index.html"><img src="img/axiom-logo.png"></a>
          <h3 class="masthead-title">
            <span>axiom//rabbit-microservices.core</span>
            <small>A Microservices Framwork Based on RabbitMQ</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="page">
          <div class="heading">
            <div>
              <h5>Author: Boaz Rosenan&nbsp;&nbsp;<a href="mailto:brosenan@gmail.com">(brosenan@gmail.com)</a></h5>
              <h5>Date: 21 May 2017</h5>
              <h5>Repository: <a href="https://github.com/brosenan/axiom">https://github.com/brosenan/axiom</a></h5>
              <h5>Version: 0.1.0-SNAPSHOT</h5></div></div>
          <hr/>
          <div class="outline">
            <div class="toc">
              <nav data-gumshoe-header>
                <ul data-gumshoe>
                  <a data-scroll class="top" href="#page-top">TOP</a>
                  <li><a class="chapter" data-scroll="" href="#introduction"><h4>1 &nbsp; Introduction</h4></a></li><li><a class="chapter" data-scroll="" href="#serve"><h4>2 &nbsp; serve: Register an Event Handler</h4></a></li><li><a class="chapter" data-scroll="" href="#declare-service"><h4>3 &nbsp; declare-service: Declare an AMQP Queue</h4></a></li><li><a class="chapter" data-scroll="" href="#assign-service"><h4>4 &nbsp; assign-service: Register an Event Handler</h4></a></li><li><a class="chapter" data-scroll="" href="#publish"><h4>5 &nbsp; publish: Publish an Event from the Outside</h4></a></li><li><a class="chapter" data-scroll="" href="#usage-example"><h4>6 &nbsp; Usage Example</h4></a></li><li><a class="chapter" data-scroll="" href="#under-the-hood"><h4>7 &nbsp; Under the Hood</h4></a><a class="section" data-scroll="" href="#create-service"><h5><i>7.1 &nbsp; create-service: Initialization</i></h5></a><a class="section" data-scroll="" href="#event-routing-key"><h5><i>7.2 &nbsp; event-routing-key</i></h5></a><a class="section" data-scroll="" href="#handle-event"><h5><i>7.3 &nbsp; handle-event</i></h5></a></li>
                </ul>
              </nav>
            </div>
          </div>

          <div class="toc">
              <nav>
                <ul>
                  <li><a class="chapter" data-scroll="" href="#introduction"><h4>1 &nbsp; Introduction</h4></a></li><li><a class="chapter" data-scroll="" href="#serve"><h4>2 &nbsp; serve: Register an Event Handler</h4></a></li><li><a class="chapter" data-scroll="" href="#declare-service"><h4>3 &nbsp; declare-service: Declare an AMQP Queue</h4></a></li><li><a class="chapter" data-scroll="" href="#assign-service"><h4>4 &nbsp; assign-service: Register an Event Handler</h4></a></li><li><a class="chapter" data-scroll="" href="#publish"><h4>5 &nbsp; publish: Publish an Event from the Outside</h4></a></li><li><a class="chapter" data-scroll="" href="#usage-example"><h4>6 &nbsp; Usage Example</h4></a></li><li><a class="chapter" data-scroll="" href="#under-the-hood"><h4>7 &nbsp; Under the Hood</h4></a><a class="section" data-scroll="" href="#create-service"><h5><i>7.1 &nbsp; create-service: Initialization</i></h5></a><a class="section" data-scroll="" href="#event-routing-key"><h5><i>7.2 &nbsp; event-routing-key</i></h5></a><a class="section" data-scroll="" href="#handle-event"><h5><i>7.3 &nbsp; handle-event</i></h5></a></li>
                </ul>
              </nav>
          </div>
          <div><span id="introduction"></span><h2><b>1 &nbsp;&nbsp; Introduction</b></h2></div><div><p><code>rabbit-microservices</code> is a library that supports the definition of microservices. It <a href='di.html#provide'>provides</a> the <code>serve</code> function as a <a href='di.html'>resource</a>. In turn, the <code>serve</code> function registers given functions to a subset of the events published through AMQP. It is provided a partial event, and calls the given function on any event that matches the given partial event.</p></div><div><p>The event structure we refer to here is the one discussed in <a href='cloudlog-events.html'>cloudlog-events</a>.</p></div><div><span id="serve"></span><h2><b>2 &nbsp;&nbsp; serve: Register an Event Handler</b></h2></div><div><p><code>serve</code> is a <a href='di.html'>dependency-injection resource</a> which depends on two functions:</p><ol><li><a href='#declare-service'>declare-service</a>, and</li><li><a href='#assign-service'>assign-service</a></li></ol></div><div><p>We will consider the following service function for the examples below:</p></div><div class="code"><pre><code class="clojure">(defn my-service [ev])</code></pre></div><div><p>It takes a service function and a partial event, and does the following:</p><ol><li>Based on the name of the function, it creates a queue name and calls <code>declare-service</code> to declare it.</li><li>It then assigns the function to the service by calling <code>assign-service</code>.</li></ol></div><div class="code"><pre><code class="clojure">(let [calls (transient [])
     $ (di/injector {:declare-service (fn [key reg] (conj! calls [:declare-service key reg]))
                     :assign-service (fn [key func] (conj! calls [:assign-service key func]))})]
 (module $)
 (di/startup $)
 (di/do-with! $ [serve]
   (serve my-service {:partial :event}) =&gt; nil
   (persistent! calls) =&gt; [[:declare-service &quot;rabbit-microservices.core-test/my-service&quot; {:partial :event}]
                           [:assign-service &quot;rabbit-microservices.core-test/my-service&quot; my-service]]))</code></pre></div><div><span id="declare-service"></span><h2><b>3 &nbsp;&nbsp; declare-service: Declare an AMQP Queue</b></h2></div><div><p><code>declare-service</code> depends on an <code>amqp-service</code> resource (which itself depends on <code>amqp-config</code>).</p></div><div class="code"><pre><code class="clojure">(let [$ (di/injector {:amqp-service {:chan :some-chan}})]
 (module $)
 (di/startup $)
 (def declare-service (di/do-with! $ [declare-service] declare-service)))</code></pre></div><div><p><code>declare-service</code> declares a queue and binds it to the <code>facts</code> exchange to receive events matching the given partial event.</p></div><div class="code"><pre><code class="clojure">(declare-service &quot;foobar&quot; {:kind :fact
                          :name &quot;foo/bar&quot;}) =&gt; nil
 (provided
(lq/declare :some-chan &quot;foobar&quot;) =&gt; irrelevant
(lq/bind :some-chan &quot;foobar&quot;
         facts-exch {:routing-key &quot;f.17cdeaefa5cc6022481c824e15a47a7726f593dd.#&quot;}) =&gt; irrelevant)</code></pre></div><div><span id="assign-service"></span><h2><b>4 &nbsp;&nbsp; assign-service: Register an Event Handler</b></h2></div><div><p><code>assign-service</code> depends on an <code>amqp-service</code>.</p></div><div class="code"><pre><code class="clojure">(let [$ (di/injector {:amqp-service {:chan :some-chan}})]
 (module $)
 (di/startup $)
 (def assign-service (di/do-with! $ [assign-service] assign-service)))</code></pre></div><div><p><code>assign-service</code> takes a key that was previously <a href='#declare-service'>declared</a> and a service function, and subscribes to this queue using a function that wraps the given function.</p></div><div class="code"><pre><code class="clojure">(assign-service &quot;foobar&quot; my-service) =&gt; nil
 (provided
(lc/subscribe :some-chan &quot;foobar&quot; irrelevant {:auto-ack true}) =&gt; irrelevant)</code></pre></div><div><p>Auto acknowledgement is disabled when the provided function has three parameters. The third of which is expected to be bound to an explicit <code>ack</code> function.</p></div><div class="code"><pre><code class="clojure">(defn my-other-service [event publish ack])</code></pre></div><div class="code"><pre><code class="clojure">(assign-service &quot;foobar&quot; my-other-service) =&gt; nil
 (provided
(lc/subscribe :some-chan &quot;foobar&quot; irrelevant {:auto-ack false}) =&gt; irrelevant)</code></pre></div><div><span id="publish"></span><h2><b>5 &nbsp;&nbsp; publish: Publish an Event from the Outside</b></h2></div><div><p><code>publish</code> is a service that allows its users to publish events from outside the context of a service. It depends on <code>amqp-service</code>.</p></div><div class="code"><pre><code class="clojure">(let [$ (di/injector {:amqp-service {:chan :some-chan}})]
 (module $)
 (di/startup $)
 (def publish (di/do-with! $ [publish] publish)))</code></pre></div><div class="code"><pre><code class="clojure">(publish ..ev..) =&gt; nil
 (provided
(nippy/freeze ..ev..) =&gt; ..bin..
(event-routing-key ..ev..) =&gt; ..routing-key..
(lb/publish :some-chan facts-exch ..routing-key.. ..bin.. {}) =&gt; irrelevant)</code></pre></div><div><span id="usage-example"></span><h2><b>6 &nbsp;&nbsp; Usage Example</b></h2></div><div><p>To demonstrate how the above functions work together we build a small usage example.</p></div><div><p>In our example we have the following service functions:</p><ol><li>Function <code>sum-foo</code> that sums the values in the data of events of name "foo" and emits events named "foo-sum".</li><li>Function <code>count-ev</code> that counts the events of the different names and emits events of type "count" (it does not count "count" events).</li><li>Function <code>foo-from-count</code> that listens on "count" events and emits corresponding "foo" events with the same value.</li></ol></div><div class="code"><pre><code class="clojure">:integ ; Integration test.  Does not run during continouts integration
 (def foo-sum (atom 0))
 (def ev-count (atom {}))
 (def $ (di/injector))
 (module $)
 (di/do-with $ [serve]
 (println &quot;Registering services&quot;)
 (serve (fn ;; sum-foo
          [ev pub]
          (swap! foo-sum (partial + (:data ev)))
          (pub {:kind :fact
                :name &quot;foo-sum&quot;
                :key 0
                :data @foo-sum}))
        {:kind :fact
         :name &quot;foo&quot;})

 (serve (fn  ;; count-ev
          [ev pub]
          (let [key (:name ev)]
            (swap! ev-count (fn [m]
                              (let [old (or (m key) 0)
                                    new (inc old)]
                                (assoc m key new))))
            (pub {:kind :fact
                  :name &quot;count&quot;
                  :key key
                  :data (@ev-count key)})))
        {:kind :fact})

 (serve (fn ;; foo-from-count
          [ev pub]
          (pub {:kind :fact
                :name &quot;foo&quot;
                :key (:key ev)
                :data (:data ev)}))
        {:kind :fact
         :name &quot;count&quot;}))</code></pre></div><div><p>For the <code>serve</code> resource to initialize, we need to provide an <code>amqp-config</code> resource with values needed for the underlying <code>langohr</code> library to find the AMQP broker. We will use the default values.</p></div><div class="code"><pre><code class="clojure">:integ
 (di/provide $ amqp-config []
           rmq/*default-config*)
 (di/startup $)</code></pre></div><div><p>Now our service is ready to roll.<br /> All we need is to get the fire started is a little match &ndash; a single event.</p></div><div class="code"><pre><code class="clojure">:integ ; Integration test.  Does not run during continouts integration
    (di/do-with! $ [publish]
                 (println &quot;Kicking the first event&quot;)
                 (publish {:kind :fact
                           :name &quot;foo&quot;
                           :key 0
                           :data 1}))
    (println &quot;waiting for the sum to reach ten-milion&quot;)
    (while (&lt; @foo-sum 10000000)
      (Thread/sleep 100))
    (println &quot;done!&quot;)</code></pre></div><div><span id="under-the-hood"></span><h2><b>7 &nbsp;&nbsp; Under the Hood</b></h2></div><div><span id="create-service"></span><h3>7.1 &nbsp;&nbsp; create-service: Initialization</h3></div><div><p><code>create-service</code> initializes a connection and a channel to RabbitMQ. It also declares the <code>facts</code> exchange, which is a topic-based AMQP exchange. The returned map contains the connection, the channel and an <code>:alive</code> atom, that defaults to <code>true</code>.</p></div><div class="code"><pre><code class="clojure">(let [srv (create-service)]
 [(:conn srv) (:chan srv) @(:alive srv)]) =&gt; [..conn.. ..chan.. true]
 (provided
(rmq/connect) =&gt; ..conn..
(lch/open ..conn..) =&gt; ..chan..
(le/declare ..chan.. facts-exch &quot;topic&quot;) =&gt; irrelevant)</code></pre></div><div><p>The dynamic variable <code>langohr.core/&#42;default-config&#42;</code> controls the configuration.  See the <a href='http://clojurerabbitmq.info'>Langohr documentation</a> for more information.</p></div><div><span id="event-routing-key"></span><h3>7.2 &nbsp;&nbsp; event-routing-key</h3></div><div><p>The <code>event-routing-key</code> function returns a AMQP-conforming routing key for a given event map.</p></div><div class="code"><pre><code class="clojure">(event-routing-key {:kind :fact
                   :name &quot;foo/bar&quot;
                   :key 1234
                   :ts 1000
                   :data [&quot;foo&quot; :bar]
                   :change 1
                   :writers #{}
                   :readers #{}}) =&gt; &quot;f.17cdeaefa5cc6022481c824e15a47a7726f593dd.7110eda4d09e062aa5e4a390b0a572ac0d2c0220&quot;</code></pre></div><div><p>The initial <code>f</code> is derived from <code>:kind :fact</code>.  For <code>:kind :rule</code> an exception is thrown.</p></div><div class="code"><pre><code class="clojure">(event-routing-key {:kind :rule
                   :name &quot;foo/bar&quot;
                   :key 1234
                   :ts 1000
                   :data [&quot;foo&quot; :bar]
                   :change 1
                   :writers #{}
                   :readers #{}}) =&gt; (throws &quot;Only fact events are supported&quot;)</code></pre></div><div><p>The ony fields that effect the routing key are <code>kind</code>, <code>name</code> and <code>key</code>.</p></div><div class="code"><pre><code class="clojure">(let [base  (event-routing-key {:kind :fact
                                    :name &quot;foo/bar&quot;
                                    :key 1234
                                    :ts 1000
                                    :data [&quot;foo&quot; :bar]
                                    :change 1
                                    :writers #{}
                                    :readers #{}})]
      (= (event-routing-key {:kind :fact
                             :name &quot;foo/bar&quot;
                             :key 1234
                             :ts 1001
                             :data [&quot;fool&quot; :baz]
                             :change -1
                             :writers #{:me}
                             :readers #{:you}}) base) =&gt; true
      (= (event-routing-key {:kind :fact
                             :name &quot;foo/baz&quot; ; Different name
                             :key 1234
                             :ts 1001
                             :data [&quot;fool&quot; :baz]
                             :change -1
                             :writers #{:me}
                             :readers #{:you}}) base) =&gt; false
      (= (event-routing-key {:kind :fact
                             :name &quot;foo/bar&quot;
                             :key [:foo :bar] ; Different key
                             :ts 1001
                             :data [&quot;fool&quot; :baz]
                             :change -1
                             :writers #{:me}
                             :readers #{:you}}) base) =&gt; false)</code></pre></div><div><p><code>event-routing-key</code> can handle partial events. If <code>:name</code> is omitted, a pattern that matches all facts is returned.</p></div><div class="code"><pre><code class="clojure">(event-routing-key {:kind :fact}) =&gt; &quot;f.#&quot;</code></pre></div><div><p>If <code>:name</code> is provided, but <code>:key</code> is omitted, a pattern matching all keys with that name is returned.</p></div><div class="code"><pre><code class="clojure">(event-routing-key {:kind :fact
                   :name &quot;foo/bar&quot;}) =&gt; #&quot;f&#92;.[0-9a-f]+&#92;.#&quot;</code></pre></div><div><span id="handle-event"></span><h3>7.3 &nbsp;&nbsp; handle-event</h3></div><div><p><code>handle-event</code> takes a function to be called when an event arrives and the <code>:alive</code> atom for the service  along with arguments provided by a subscription to a queue,  so that the function <code>&#40;partial handle-event some-func alive&#41;</code> can be used with <code>lc/subscribe</code>.</p></div><div><p>The wrapped function can take one, two, or three parameters. If it takes one parameter, we pass this parameter a de-serialization of the event.</p></div><div class="code"><pre><code class="clojure">(def alive (atom true))
 (def received (atom '()))
 (defn my-func
 {:reg {:kind :fact
        :name &quot;foo/bar&quot;}}
 [ev]
 (swap! received #(conj % ev)))
 (def my-event {:kind :fact
              :name &quot;foo/bar&quot;
              :key 1234
              :ts 1000
              :data [&quot;foo&quot; :bar]
              :change 1
              :writers #{}
              :readers #{}})
 (def my-event-bin (nippy/freeze my-event))
 ; By running handle-event...
 (handle-event my-func alive :the-channel {:delivery-tag 777} my-event-bin) =&gt; nil
 ; we execute my-func, which adds the event to received
 @received =&gt; [my-event]</code></pre></div><div><p>If the wrapped function accepts two parameters, the second parameter is taken to be a <code>publish</code> function, which publishes events on the facts exchange. The event handler (<code>my-func</code> in the example below) does not have to specify all fields in the event it publishes (<code>event2</code> in the example). All fields that are not specified in the event default to their values in the event that triggerred the function (<code>event-that-was-sent</code> in the example).</p></div><div class="code"><pre><code class="clojure">(def event2 {:name &quot;foo/baz&quot;
            :key 5555
            :data [1 2 3 4]})
 (defn my-func
 {:reg {:kind :fact
        :name &quot;foo/bar&quot;}}
 [ev publish]
 (publish event2))
 (def event-that-was-sent
 (merge my-event event2))
 (handle-event my-func alive :the-channel :meta-attrs my-event-bin) =&gt; nil
 (provided
(nippy/freeze event-that-was-sent) =&gt; ..bin..
(lb/publish :the-channel facts-exch (event-routing-key event2) ..bin.. :meta-attrs) =&gt; irrelevant)</code></pre></div><div><p>When the <code>alive</code> atom evaluates to <code>false</code>, the publish function does nothing.</p></div><div class="code"><pre><code class="clojure">(reset! alive false)
 (handle-event my-func alive :the-channel :meta-attrs my-event-bin) =&gt; nil
 ; Nothing is published</code></pre></div><div><p>If the wrapped function accepts three parameters, the third parameter is taken to be an <code>ack</code> function, that explicitly acknowledges the received event.</p></div><div class="code"><pre><code class="clojure">(defn my-func
 {:reg {:kind :fact
        :name &quot;foo/bar&quot;}}
 [ev publish ack]
 (ack))
 (handle-event my-func alive :the-channel {:delivery-tag &quot;foo&quot;} my-event-bin) =&gt; nil
 (provided
(lb/ack :the-channel &quot;foo&quot;) =&gt; irrelevant)</code></pre></div>
        </div>
      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>
  </body>

  <script>
  if (false) {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', '<@=tracking>', 'caudate.me');
    ga('send', 'pageview');
  }
  </script>
  
  <script type="text/javascript">
    smoothScroll.init();
    gumshoe.init({});
  
    hljs.registerLanguage("clojure",function(e){var t={"builtin-name":"def defonce cond apply if-not if-let if not not= = < > <= >= == + / * - rem quot neg? pos? delay? symbol? keyword? true? false? integer? empty? coll? list? set? ifn? fn? associative? sequential? sorted? counted? reversible? number? decimal? class? distinct? isa? float? rational? reduced? ratio? odd? even? char? seq? vector? string? map? nil? contains? zero? instance? not-every? not-any? libspec? -> ->> .. . inc compare do dotimes mapcat take remove take-while drop letfn drop-last take-last drop-while while intern condp case reduced cycle split-at split-with repeat replicate iterate range merge zipmap declare line-seq sort comparator sort-by dorun doall nthnext nthrest partition eval doseq await await-for let agent atom send send-off release-pending-sends add-watch mapv filterv remove-watch agent-error restart-agent set-error-handler error-handler set-error-mode! error-mode shutdown-agents quote var fn loop recur throw try monitor-enter monitor-exit defmacro defn defn- macroexpand macroexpand-1 for dosync and or when when-not when-let comp juxt partial sequence memoize constantly complement identity assert peek pop doto proxy defstruct first rest cons defprotocol cast coll deftype defrecord last butlast sigs reify second ffirst fnext nfirst nnext defmulti defmethod meta with-meta ns in-ns create-ns import refer keys select-keys vals key val rseq name namespace promise into transient persistent! conj! assoc! dissoc! pop! disj! use class type num float double short byte boolean bigint biginteger bigdec print-method print-dup throw-if printf format load compile get-in update-in pr pr-on newline flush read slurp read-line subvec with-open memfn time re-find re-groups rand-int rand mod locking assert-valid-fdecl alias resolve ref deref refset swap! reset! set-validator! compare-and-set! alter-meta! reset-meta! commute get-validator alter ref-set ref-history-count ref-min-history ref-max-history ensure sync io! new next conj set! to-array future future-call into-array aset gen-class reduce map filter find empty hash-map hash-set sorted-map sorted-map-by sorted-set sorted-set-by vec vector seq flatten reverse assoc dissoc list disj get union difference intersection extend extend-type extend-protocol int nth delay count concat chunk chunk-buffer chunk-append chunk-first chunk-rest max min dec unchecked-inc-int unchecked-inc unchecked-dec-inc unchecked-dec unchecked-negate unchecked-add-int unchecked-add unchecked-subtract-int unchecked-subtract chunk-next chunk-cons chunked-seq? prn vary-meta lazy-seq spread list* str find-keyword keyword symbol gensym force rationalize"},r="a-zA-Z_\\-!.?+*=<>&#'",n="["+r+"]["+r+"0-9/;:]*",a="[-+]?\\d+(\\.\\d+)?",o={b:n,r:0},s={cN:"number",b:a,r:0},i=e.inherit(e.QSM,{i:null}),c=e.C(";","$",{r:0}),d={cN:"literal",b:/\b(true|false|nil)\b/},l={b:"[\\[\\{]",e:"[\\]\\}]"},m={cN:"comment",b:"\\^"+n},p=e.C("\\^\\{","\\}"),u={cN:"symbol",b:"[:]{1,2}"+n},f={b:"\\(",e:"\\)"},h={eW:!0,r:0},y={k:t,l:n,cN:"name",b:n,starts:h},b=[f,i,m,p,c,u,l,s,d,o];return f.c=[e.C("comment",""),y,h],h.c=b,l.c=b,{aliases:["clj"],i:/\S/,c:[f,i,m,p,c,u,l,s,d]}});
    hljs.initHighlightingOnLoad();
  </script>
</html>
