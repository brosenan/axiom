
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <link rel="shortcut icon" href="favicon.ico">
  <title>axiom//di.core - Dependency Injection</title>
  <script src="js/highlight.min.js"></script>
  <script src="js/gumshoe.min.js"></script>
  <script src="js/smooth-scroll.min.js"></script>
  
  <!-- CSS -->
  <link rel="stylesheet" href="css/poole.css">
  <link rel="stylesheet" href="css/syntax.css">
  <link rel="stylesheet" href="css/lanyon.css">
  <link rel="stylesheet" href="css/bolton.css">
  <link rel="stylesheet" href="css/bolton-api.css">
  <link rel="stylesheet" href="css/bolton-highlight.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">
  
</head>

  <body class="theme-base-08">
    <span id="page-top"></span>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <nav class="sidebar-nav">
    <span>&nbsp;</span>
    <a class="sidebar-nav-item header" href="index.html"><img src="img/logo-white.png"/></a>
    <span>&nbsp;</span>
    <a class="sidebar-nav-item" href="axiom-clj.html">axiom-clj.core</a><a class="sidebar-nav-item" href="cloudlog.html">cloudlog.core</a><a class="sidebar-nav-item" href="cloudlog-events.html">cloudlog-events.core</a><a class="sidebar-nav-item" href="cloudlog.graph.html">cloudlog.graph</a><a class="sidebar-nav-item" href="cloudlog.interset.html">cloudlog.interset</a><a class="sidebar-nav-item active" href="di.html">di.core</a><a class="sidebar-nav-item" href="docs.html"></a><a class="sidebar-nav-item" href="dynamo.html">dynamo.core</a><a class="sidebar-nav-item" href="gateway.html">gateway.core</a><a class="sidebar-nav-item" href="migrator.html">migrator.core</a><a class="sidebar-nav-item" href="permacode.html">permacode.core</a><a class="sidebar-nav-item" href="permacode.hasher.html">permacode.hasher</a><a class="sidebar-nav-item" href="permacode.publish.html">permacode.publish</a><a class="sidebar-nav-item" href="permacode.symbols.html">permacode.symbols</a><a class="sidebar-nav-item" href="permacode.validate.html">permacode.validate</a><a class="sidebar-nav-item" href="rabbit-microservices.html">rabbit-microservices.core</a><a class="sidebar-nav-item" href="s3.html">s3.core</a><a class="sidebar-nav-item" href="storm.html">storm.core</a><a class="sidebar-nav-item" href="zk-plan.html">zk-plan.core</a>
    <span class="sidebar-nav-item">&nbsp;</span>
    <span class="sidebar-nav-item">&nbsp;</span>
  </nav>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
	  <a href="index.html"><img src="img/axiom-logo.png"></a>
          <h3 class="masthead-title">
            <span>axiom//di.core</span>
            <small>Dependency Injection</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="page">
          <div class="heading">
            <div>
              <h5>Author: Boaz Rosenan&nbsp;&nbsp;<a href="mailto:brosenan@gmail.com">(brosenan@gmail.com)</a></h5>
              <h5>Date: 29 June 2017</h5>
              <h5>Repository: <a href="https://github.com/brosenan/axiom">https://github.com/brosenan/axiom</a></h5>
              <h5>Version: 0.1.0-SNAPSHOT</h5></div></div>
          <hr/>
          <div class="outline">
            <div class="toc">
              <nav data-gumshoe-header>
                <ul data-gumshoe>
                  <a data-scroll class="top" href="#page-top">di.core</a>
                  <li><a class="chapter" data-scroll="" href="#intoduction"><h4>1 &nbsp; Intoduction</h4></a></li><li><a class="chapter" data-scroll="" href="#injector"><h4>2 &nbsp; injector</h4></a></li><li><a class="chapter" data-scroll="" href="#provide"><h4>3 &nbsp; provide</h4></a></li><li><a class="chapter" data-scroll="" href="#do-with"><h4>4 &nbsp; do-with</h4></a></li><li><a class="chapter" data-scroll="" href="#startup"><h4>5 &nbsp; startup</h4></a></li><li><a class="chapter" data-scroll="" href="#shutdown"><h4>6 &nbsp; shutdown</h4></a></li><li><a class="chapter" data-scroll="" href="#do-with-0"><h4>7 &nbsp; do-with!</h4></a></li><li><a class="chapter" data-scroll="" href="#do-with-default"><h4>8 &nbsp; do-with-default!</h4></a></li><li><a class="chapter" data-scroll="" href="#default-rules"><h4>9 &nbsp; Default Rules</h4></a><a class="section" data-scroll="" href="#time"><h5><i>9.1 &nbsp; time</i></h5></a><a class="section" data-scroll="" href="#println"><h5><i>9.2 &nbsp; println</i></h5></a><a class="section" data-scroll="" href="#format-time"><h5><i>9.3 &nbsp; format-time</i></h5></a><a class="section" data-scroll="" href="#logging"><h5><i>9.4 &nbsp; logging</i></h5></a><a class="section" data-scroll="" href="#sh"><h5><i>9.5 &nbsp; sh</i></h5></a></li><li><a class="chapter" data-scroll="" href="#under-the-hood"><h4>10 &nbsp; Under the Hood</h4></a></li>
                </ul>
              </nav>
            </div>
          </div>

          <div class="toc">
              <nav>
                <ul>
                  <li><a class="chapter" data-scroll="" href="#intoduction"><h4>1 &nbsp; Intoduction</h4></a></li><li><a class="chapter" data-scroll="" href="#injector"><h4>2 &nbsp; injector</h4></a></li><li><a class="chapter" data-scroll="" href="#provide"><h4>3 &nbsp; provide</h4></a></li><li><a class="chapter" data-scroll="" href="#do-with"><h4>4 &nbsp; do-with</h4></a></li><li><a class="chapter" data-scroll="" href="#startup"><h4>5 &nbsp; startup</h4></a></li><li><a class="chapter" data-scroll="" href="#shutdown"><h4>6 &nbsp; shutdown</h4></a></li><li><a class="chapter" data-scroll="" href="#do-with-0"><h4>7 &nbsp; do-with!</h4></a></li><li><a class="chapter" data-scroll="" href="#do-with-default"><h4>8 &nbsp; do-with-default!</h4></a></li><li><a class="chapter" data-scroll="" href="#default-rules"><h4>9 &nbsp; Default Rules</h4></a><a class="section" data-scroll="" href="#time"><h5><i>9.1 &nbsp; time</i></h5></a><a class="section" data-scroll="" href="#println"><h5><i>9.2 &nbsp; println</i></h5></a><a class="section" data-scroll="" href="#format-time"><h5><i>9.3 &nbsp; format-time</i></h5></a><a class="section" data-scroll="" href="#logging"><h5><i>9.4 &nbsp; logging</i></h5></a><a class="section" data-scroll="" href="#sh"><h5><i>9.5 &nbsp; sh</i></h5></a></li><li><a class="chapter" data-scroll="" href="#under-the-hood"><h4>10 &nbsp; Under the Hood</h4></a></li>
                </ul>
              </nav>
          </div>
          <div><span id="intoduction"></span><h2><b>1 &nbsp;&nbsp; Intoduction</b></h2></div><div><p><a href='https://en.wikipedia.org/wiki/Dependency_injection'>Dependency Injection</a> (DI) is a practice by which code assets receive their dependencies from their surroundings at runtime, as opposed to the practice in which they are compiled against these dependencies. This allows different modules to be decoupled from one another, making software more modular and easier to modify and test.</p></div><div><p>The basic building block in DI is a <em>resource</em>. In our implementation, a resource can be any Clojure value. Such a value could be a function that does something, a configuration value such as a number or a string, an object representing a connection to an external server or anything else.</p></div><div><p>Resources are defined by <em>modules</em>, which are Clojure functions (typically named <code>module</code>), that contribute rules that provide and use resources.</p></div><div><p>The state of the injection is maintained by an <em>injector</em>. An empty injector is created using the <a href='#injector'>injector</a> function. <code>module</code> functions take an injector and <a href='#provide'>provide</a> resources to it. Modules can also define initialization operations that do not result in a resource, using the <code>do-with</code> macro.</p></div><div><p>The initializations defined by modules do not take effect until the <a href='#startup'>startup</a> function is called. This function executes all initialization operations in order. Once <code>startup</code> has completed, all initialization operations have been performed.</p></div><div><p>Modules can also associate resources with shutdown operations. The <a href='#shutdown'>shutdown</a> function performs a shutdown sequence, executed in reverse order relative to the strtup sequence  to make sure no dependencies are dropped before they are shut down properly.</p></div><div><span id="injector"></span><h2><b>2 &nbsp;&nbsp; injector</b></h2></div><div><p><code>injector</code> creates an empty injector. By convention, injectors are bound to the variable <code>$</code>. The injector is an atom holding a map. It has the following fields:</p><ol><li><code>:resources</code>: A map containing the currently initialized resources.</li><li><code>:rule</code>: An atom holding a sequence of rules contributed by modules.</li><li><code>:shutdown</code>: An atom holding a sequence of shutdown operations to be executed.</li></ol></div><div class="code"><pre><code class="clojure">(let [$ (injector)]
 @$ =&gt; map?
 (:resources @$) =&gt; map?
 (:rules @$) =&gt; sequential?
 (:shutdown @$) =&gt; [])</code></pre></div><div><p>An optional argument provides a map with initial resource values.</p></div><div class="code"><pre><code class="clojure">(let [$ (injector {:foo 1
                  :bar 2})
     res (:resources @$)]
 (:foo res) =&gt; 1
 (:bar res) =&gt; 2)</code></pre></div><div><span id="provide"></span><h2><b>3 &nbsp;&nbsp; provide</b></h2></div><div><p>The <code>provide</code> macro provides a rule for providing a resource that may or may not depend on other resources.</p></div><div><p>It takes an injector, the name of the new resource, a list of dependencies and code that evaluates the resource. It places a function in the <code>:rules</code> list in the injector, that when called with the resource map as its parameter,  returns the value of the new resource. The function is given two meta fields: <code>:resource</code>, containing the name of the target resource, and <code>:deps</code>, containing the dependencies. Both <code>:resource</code> and <code>:deps</code> hold resource names as keywords.</p></div><div class="code"><pre><code class="clojure">(let [$ (injector)]
 (provide $ baz [foo bar]
          (+ foo bar))
 (let [func (last (:rules @$))]
   (func {:foo 1
          :bar 2}) =&gt; 3
   (-&gt; func meta :resource) =&gt; :baz
   (-&gt; func meta :deps) =&gt; [:foo :bar]))</code></pre></div><div><span id="do-with"></span><h2><b>4 &nbsp;&nbsp; do-with</b></h2></div><div><p>Modules can also define actions with side effects that do not result in a new resource. <code>do-with</code> is a macro similar to <a href='#provide'>provide</a>, that adds a rule to the injector, but it is not given a resource name, and therefore does not set the <code>:resource</code> meta field in the function.</p></div><div class="code"><pre><code class="clojure">(let [res (atom nil)
     $ (injector)]
 (do-with $ [foo bar]
          (reset! res (+ foo bar)))
 (let [func (last (:rules @$))]
   (-&gt; func meta :deps) =&gt; [:foo :bar]
   (func {:foo 1
          :bar 2})
   @res =&gt; 3))</code></pre></div><div><span id="startup"></span><h2><b>5 &nbsp;&nbsp; startup</b></h2></div><div><p>After all modules contributed rules to the injector, the <code>startup</code> function runs a startup sequence based on these rules.</p></div><div><p>For resources without dependencies, action is performed in arbitrary order.</p></div><div class="code"><pre><code class="clojure">(let [res (transient #{})
     $ (injector)]
 (provide $ foo []
          (conj! res :foo)
          1)
 (provide $ bar []
          (conj! res :bar)
          2)
 (startup $)
 (persistent! res) =&gt; #{:foo :bar})</code></pre></div><div><p>When depndencies exist, functions are applied according to dependency order.</p></div><div class="code"><pre><code class="clojure">(let [res (atom nil)
     $ (injector)]
 (do-with $ [foo bar]
          (reset! res (str &quot;foo is &quot; foo &quot; and bar is &quot; bar)))
 (provide $ bar [foo]
          (inc foo))
 (provide $ foo []
          1)
 (startup $)
 @res =&gt; &quot;foo is 1 and bar is 2&quot;)</code></pre></div><div><p>A function is only executed if all its dependencies are present.</p></div><div class="code"><pre><code class="clojure">(let [$ (injector)]
 (provide $ foo [resource-that-does-not-exist]
          (throw (Exception. &quot;This code should not run&quot;)))
 (startup $) =&gt; nil)</code></pre></div><div><p>The resource values provided by rules are updated in the injector's <code>:resources</code> map.</p></div><div class="code"><pre><code class="clojure">(let [$ (injector)]
 (provide $ foo []
          7)
 (startup $)
 (-&gt; @$ :resources :foo) =&gt; 7)</code></pre></div><div><p>If a resource was defined during the initialization of the injector, the operation is skipped.</p></div><div class="code"><pre><code class="clojure">(let [$ (injector {:to-skip 8})]
 (provide $ to-skip []
          (throw (Exception. &quot;This should not be called&quot;)))
 (startup $)
 (-&gt; @$ :resources :to-skip) =&gt; 8)</code></pre></div><div><span id="shutdown"></span><h2><b>6 &nbsp;&nbsp; shutdown</b></h2></div><div><p>When <a href='#provide'>provide</a>ing a resource, it is possible to also provide a <code>:shutdown</code> function. This is done by returning an object containing only these two fields:</p><ol><li><code>:resource</code>: The resource value, and</li><li><code>:shutdown</code>: A function which, when called, cleans up the resource.</li></ol></div><div class="code"><pre><code class="clojure">(let [$ (injector)
     func (fn [])]
 (provide $ foo []
          {:resource 2
           :shutdown (fn [])})
 (provide $ bar []
          {:resource 3
           :shutdown func
           :something-else 7})
 (startup $)
 (-&gt; @$ :resources :foo) =&gt; 2
 (-&gt; @$ :resources :bar) =&gt; {:resource 3
                             :shutdown func
                             :something-else 7})</code></pre></div><div><p>The <code>:shutdown</code> functions are accumulated in reverse order in the injector's <code>:shutdown</code> sequence.</p></div><div class="code"><pre><code class="clojure">(let [$ (injector)]
 (provide $ foo []
          {:resource 1
           :shutdown :some-func1})
 (provide $ bar [foo]
          {:resource 2
           :shutdown :some-func2})
 (provide $ baz [bar]
          {:resource 3
           :shutdown :some-func3})
 (startup $)
 (:shutdown @$) =&gt; [:some-func3 :some-func2 :some-func1])</code></pre></div><div><p>The <code>shutdown</code> function executes the injector's shutdown sequence.</p></div><div class="code"><pre><code class="clojure">(let [res (transient [])
     $ (injector)]
 (provide $ foo []
          {:resource 1
           :shutdown (fn [] (conj! res :foo))})
 (provide $ bar [foo]
          {:resource 2
           :shutdown (fn [] (conj! res :bar))})
 (provide $ baz [bar]
          {:resource 3
           :shutdown (fn [] (conj! res :baz))})
 (startup $)
 (shutdown $)
 (persistent! res) =&gt; [:baz :bar :foo])</code></pre></div><div><span id="do-with-0"></span><h2><b>7 &nbsp;&nbsp; do-with!</b></h2></div><div><p>The <code>do-with!</code> macro has similar semantics to <a href='#do-with'>do-with</a>, but instead of providing a rule to the injector prior to <code>startup</code>, <code>do-with!</code> perform the enclosed operation (and returns its value) assuming <code>startup</code> has already been called.</p></div><div class="code"><pre><code class="clojure">(let [$ (injector)]
 (provide $ foo [] 1)
 (startup $)
 (do-with! $ [foo]
           (inc foo)) =&gt; 2)</code></pre></div><div><p>If one or more required resources is not available, an exception is thrown.</p></div><div class="code"><pre><code class="clojure">(let [$ (injector)]
 (provide $ foo [] 1)
 (startup $)
 (do-with! $ [bar]
           (inc bar)) =&gt; (throws #&quot;Resource&#92;(s&#92;) &#92;#&#92;{:bar&#92;} are not available, but &#92;#.*:foo.* are&quot;))</code></pre></div><div><span id="do-with-default"></span><h2><b>8 &nbsp;&nbsp; do-with-default!</b></h2></div><div><p>In cases when we do not know if a certain resource exists in the injector, we wish to be able to get this resource if it exists or take another default value if it does not. <code>do-with-default!</code> allows us to do just that. Its structure resembles that of a <code>let</code> form. It takes an injector (<code>$</code>), a vector consisting of a single resource name and a default value for this resource, and zero or more expressions to be evaluated.</p></div><div><p>If the resource exists, its name inside the expression is bound to its value, as in <a href='#do-with-0'>do-with!</a>.</p></div><div class="code"><pre><code class="clojure">(let [$ (injector {:foo 2})]
 (startup $)
 (do-with-default! $ [foo 4]
                   (inc foo)) =&gt; 3)</code></pre></div><div><p>If the resource does not exist, the name is bound to the provided default value.</p></div><div class="code"><pre><code class="clojure">(let [$ (injector)]
 (startup $)
 (do-with-default! $ [foo 4]
                   (inc foo)) =&gt; 5)</code></pre></div><div><p>If the second argument is not a vector, a compile-time exception is thrown.</p></div><div class="code"><pre><code class="clojure">(macroexpand `(do-with-default! $ :not-a-vector foo bar baz))
 =&gt; (throws &quot;The second argument of do-with-default! must be a vector. Given: :not-a-vector&quot;)</code></pre></div><div><p>If the second argument is not of size 2, a compile-time exception is thrown.</p></div><div class="code"><pre><code class="clojure">(macroexpand `(do-with-default! $ [:not :of :size :two] foo bar baz))
 =&gt; (throws &quot;The second argument of do-with-default! must be of size 2. Given: [:not :of :size :two]&quot;)</code></pre></div><div><span id="default-rules"></span><h2><b>9 &nbsp;&nbsp; Default Rules</b></h2></div><div><p>An empty injector comes with some rules pre-loaded. These rules are intended to provide a set of basic capabilities to be used in modules.</p></div><div><span id="time"></span><h3>9.1 &nbsp;&nbsp; time</h3></div><div><p><code>time</code> is a function that returns the current time in milliseconds.</p></div><div class="code"><pre><code class="clojure">(let [$ (injector)]
 (startup $)
 (do-with! $ [time]
           (let [t1 (time)]
             t1 =&gt; number?
             (Thread/sleep 1)
             (let [t2 (time)]
               (&gt; t2 t1) =&gt; true))))</code></pre></div><div><span id="println"></span><h3>9.2 &nbsp;&nbsp; println</h3></div><div><p><code>println</code> prints a line of text to the stndard output.</p></div><div class="code"><pre><code class="clojure">(let [$ (injector)]
 (startup $)
 (do-with! $ [println]
           (with-out-str (println &quot;foobar&quot;)) =&gt; &quot;foobar&#92;n&quot;))</code></pre></div><div><span id="format-time"></span><h3>9.3 &nbsp;&nbsp; format-time</h3></div><div><p><code>format-time</code> is a function that formats a timestamp (as given by <code>time</code>) in human-readable form.</p></div><div class="code"><pre><code class="clojure">(let [$ (injector)]
 (startup $)
 (do-with! $ [format-time]
           ;; The format is sentitive to timezone, so we match against a regex
           (format-time 1495299001266) =&gt; #&quot;May 2. 2017 ..:50:01:266 ...&quot;))</code></pre></div><div><span id="logging"></span><h3>9.4 &nbsp;&nbsp; logging</h3></div><div><p><code>log</code> is a function that logs an event. An event is given as a map of properties. It expects a <code>:format</code> field specifying the format of the logging event. The <code>:format</code> field is a tuple consisting of a string (input to <code>format</code>), and a vector of field names where the values to the format should come from. <code>log</code> uses <a href='#time'>time</a>, <a href='#format-time'>format-time</a> and <a href='#println'>println</a> to print the formatted event along with a timestamp.</p></div><div class="code"><pre><code class="clojure">(let [$ (injector {:time (constantly 1234)
                  :format-time str})]
 (startup $)
 (do-with! $ [log]
           (with-out-str (log {:format [&quot;[%s] [%d]&quot; [:foo :bar]]
                               :foo &quot;hello&quot;
                               :bar 3})) =&gt; &quot;1234 [hello] [3]&#92;n&quot;))</code></pre></div><div><p>A default format refers to the properties <code>:severity</code>, <code>:source</code> and <code>:desc</code>.</p></div><div class="code"><pre><code class="clojure">(let [$ (injector {:time (constantly 1234)
                  :format-time str})]
 (startup $)
 (do-with! $ [log]
           (with-out-str (log {:severity &quot;II&quot;
                               :source &quot;my-service&quot;
                               :desc &quot;Service is shutting down&quot;})) =&gt; &quot;1234 [II] [my-service] Service is shutting down&#92;n&quot;))</code></pre></div><div><p>The convenience functions <code>err</code>, <code>warn</code> and <code>info</code> call <a href='#log'>log</a> with a corresponding <code>:severity</code> value.</p></div><div class="code"><pre><code class="clojure">(let [$ (injector {:time (constantly 1234)
                  :format-time str})]
 (startup $)
 (do-with! $ [err warn info]
           (with-out-str (err {:source &quot;my-service&quot;
                               :desc &quot;Something went wrong&quot;}))
           =&gt; &quot;1234 [EE] [my-service] Something went wrong&#92;n&quot;
           (with-out-str (warn {:source &quot;my-service&quot;
                                :desc &quot;Something probably went wrong&quot;}))
           =&gt; &quot;1234 [WW] [my-service] Something probably went wrong&#92;n&quot;
           (with-out-str (info {:source &quot;my-service&quot;
                                :desc &quot;Something is going on&quot;}))
           =&gt; &quot;1234 [II] [my-service] Something is going on&#92;n&quot;))</code></pre></div><div><span id="sh"></span><h3>9.5 &nbsp;&nbsp; sh</h3></div><div><p>The <code>sh</code> function executes a command given as its arguments, and returns an <code>:exit</code> code as an integer, and the content of the standard <code>:out</code> and <code>:err</code> as strings.</p></div><div class="code"><pre><code class="clojure">(let [$ (injector)]
 (startup $)
 (do-with! $ [sh]
           (sh &quot;echo&quot; &quot;foo&quot;) =&gt; {:exit 0
                                 :out &quot;foo&#92;n&quot;
                                 :err &quot;&quot;}))</code></pre></div><div><span id="under-the-hood"></span><h2><b>10 &nbsp;&nbsp; Under the Hood</b></h2></div><div><p><code>rule-edges</code> converts a function representing a rule to a collection of edges in a dependency graph. Each edge is represented by a <code>&#91;src dest&#93;</code> tuple.  The nodes in that graph are either resources (keywords) or functions representing actions to be performed.</p></div><div><p>A single rule provides <code>n</code> or <code>n+1</code> edges, where <code>n</code> is the number of dependencies in the rule. For each dependency <code>d</code> we get a rule <code>&#91;d func&#93;</code>, where <code>func</code> is the rule's function.</p></div><div class="code"><pre><code class="clojure">(let [func (with-meta
            (fn [res])
            {:deps [:foo :bar]})]
 (rule-edges func) =&gt; [[:foo func] [:bar func]])</code></pre></div><div><p>In addition, if <code>func</code> has a <code>:resource</code> meta field with value <code>r</code>, a <code>&#91;func r&#93;</code> edge is added.</p></div><div class="code"><pre><code class="clojure">(let [func (with-meta (fn [res]) {:resource :baz
                                 :deps [:foo :bar]})]
 (rule-edges func) =&gt; [[func :baz] [:foo func] [:bar func]])</code></pre></div>
        </div>
      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>
  </body>

  <script>
  if (false) {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', '<@=tracking>', 'caudate.me');
    ga('send', 'pageview');
  }
  </script>
  
  <script type="text/javascript">
    smoothScroll.init();
    gumshoe.init({});
  
    hljs.registerLanguage("clojure",function(e){var t={"builtin-name":"def defonce cond apply if-not if-let if not not= = < > <= >= == + / * - rem quot neg? pos? delay? symbol? keyword? true? false? integer? empty? coll? list? set? ifn? fn? associative? sequential? sorted? counted? reversible? number? decimal? class? distinct? isa? float? rational? reduced? ratio? odd? even? char? seq? vector? string? map? nil? contains? zero? instance? not-every? not-any? libspec? -> ->> .. . inc compare do dotimes mapcat take remove take-while drop letfn drop-last take-last drop-while while intern condp case reduced cycle split-at split-with repeat replicate iterate range merge zipmap declare line-seq sort comparator sort-by dorun doall nthnext nthrest partition eval doseq await await-for let agent atom send send-off release-pending-sends add-watch mapv filterv remove-watch agent-error restart-agent set-error-handler error-handler set-error-mode! error-mode shutdown-agents quote var fn loop recur throw try monitor-enter monitor-exit defmacro defn defn- macroexpand macroexpand-1 for dosync and or when when-not when-let comp juxt partial sequence memoize constantly complement identity assert peek pop doto proxy defstruct first rest cons defprotocol cast coll deftype defrecord last butlast sigs reify second ffirst fnext nfirst nnext defmulti defmethod meta with-meta ns in-ns create-ns import refer keys select-keys vals key val rseq name namespace promise into transient persistent! conj! assoc! dissoc! pop! disj! use class type num float double short byte boolean bigint biginteger bigdec print-method print-dup throw-if printf format load compile get-in update-in pr pr-on newline flush read slurp read-line subvec with-open memfn time re-find re-groups rand-int rand mod locking assert-valid-fdecl alias resolve ref deref refset swap! reset! set-validator! compare-and-set! alter-meta! reset-meta! commute get-validator alter ref-set ref-history-count ref-min-history ref-max-history ensure sync io! new next conj set! to-array future future-call into-array aset gen-class reduce map filter find empty hash-map hash-set sorted-map sorted-map-by sorted-set sorted-set-by vec vector seq flatten reverse assoc dissoc list disj get union difference intersection extend extend-type extend-protocol int nth delay count concat chunk chunk-buffer chunk-append chunk-first chunk-rest max min dec unchecked-inc-int unchecked-inc unchecked-dec-inc unchecked-dec unchecked-negate unchecked-add-int unchecked-add unchecked-subtract-int unchecked-subtract chunk-next chunk-cons chunked-seq? prn vary-meta lazy-seq spread list* str find-keyword keyword symbol gensym force rationalize"},r="a-zA-Z_\\-!.?+*=<>&#'",n="["+r+"]["+r+"0-9/;:]*",a="[-+]?\\d+(\\.\\d+)?",o={b:n,r:0},s={cN:"number",b:a,r:0},i=e.inherit(e.QSM,{i:null}),c=e.C(";","$",{r:0}),d={cN:"literal",b:/\b(true|false|nil)\b/},l={b:"[\\[\\{]",e:"[\\]\\}]"},m={cN:"comment",b:"\\^"+n},p=e.C("\\^\\{","\\}"),u={cN:"symbol",b:"[:]{1,2}"+n},f={b:"\\(",e:"\\)"},h={eW:!0,r:0},y={k:t,l:n,cN:"name",b:n,starts:h},b=[f,i,m,p,c,u,l,s,d,o];return f.c=[e.C("comment",""),y,h],h.c=b,l.c=b,{aliases:["clj"],i:/\S/,c:[f,i,m,p,c,u,l,s,d]}});
    hljs.initHighlightingOnLoad();
  </script>
</html>
