(ns perm.QmQodG29316hRLwuJVGpCP3CW7VCJEE5KTpK6ABDBDUT1H [:require [permacode.core]] [:require [permacode.symbols :as sym]] [:require [clojure.set :as set]])(permacode.core/pure (defn at-path [tree path] (if (empty? path) tree (at-path (clojure.core/seq (clojure.core/concat (clojure.core/list tree) (clojure.core/list (first path)))) (rest path)))) (defn traverse [tree pred & [prefix]] (let [prefix (or prefix [])] (if (and (sequential? tree) (pred tree)) (apply merge (for [i (range (count tree))] (traverse (tree i) pred (concat prefix [i])))) {prefix tree}))) (defn conds-and-bindings [traventries var?] (if (empty? traventries) [[] []] (let [[conds bindings] (conds-and-bindings (rest traventries) var?) [path subtree] (first traventries)] (if (var? subtree) [conds (clojure.core/apply clojure.core/vector (clojure.core/seq (clojure.core/concat (clojure.core/list subtree) (clojure.core/list (at-path (quote $input$) (vec path))) bindings)))] [(cons (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/=)) (clojure.core/list (at-path (quote $input$) (vec path))) (clojure.core/list subtree))) conds) bindings])))) (defmacro unify-fn [vars unifiable expr] (let [vars (set vars) term-has-vars (fn [term] (not (empty? (set/intersection (sym/symbols term) vars)))) travmap (traverse unifiable (constantly true)) [conds bindings] (conds-and-bindings (map identity travmap) term-has-vars)] (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/fn)) (clojure.core/list (clojure.core/apply clojure.core/vector (clojure.core/seq (clojure.core/concat (clojure.core/list (quote $input$)))))) (clojure.core/list (clojure.core/seq (clojure.core/concat (clojure.core/list (quote if)) (clojure.core/list (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/and)) conds))) (clojure.core/list (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list bindings) (clojure.core/list (clojure.core/apply clojure.core/vector (clojure.core/seq (clojure.core/concat (clojure.core/list expr)))))))) (clojure.core/list (clojure.core/apply clojure.core/vector (clojure.core/seq (clojure.core/concat))))))))))))