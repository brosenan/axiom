
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <link rel="shortcut icon" href="favicon.ico">
  <title>axiom//dynamo.core - DynamoDB Integration</title>
  <script src="js/highlight.min.js"></script>
  <script src="js/gumshoe.min.js"></script>
  <script src="js/smooth-scroll.min.js"></script>
  
  <!-- CSS -->
  <link rel="stylesheet" href="css/poole.css">
  <link rel="stylesheet" href="css/syntax.css">
  <link rel="stylesheet" href="css/lanyon.css">
  <link rel="stylesheet" href="css/bolton.css">
  <link rel="stylesheet" href="css/bolton-api.css">
  <link rel="stylesheet" href="css/bolton-highlight.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">
  
</head>

  <body class="theme-base-08">
    <span id="page-top"></span>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <nav class="sidebar-nav">
    <span>&nbsp;</span>
    <a class="sidebar-nav-item header" href="index.html"><img src="img/logo-white.png"/></a>
    <span>&nbsp;</span>
    <a class="sidebar-nav-item" href="cloudlog.html">cloudlog.core</a><a class="sidebar-nav-item" href="cloudlog-events.html">cloudlog-events.core</a><a class="sidebar-nav-item" href="cloudlog.graph.html">cloudlog.graph</a><a class="sidebar-nav-item" href="cloudlog.interset.html">cloudlog.interset</a><a class="sidebar-nav-item" href="di.html">di.core</a><a class="sidebar-nav-item active" href="dynamo.html">dynamo.core</a><a class="sidebar-nav-item" href="dynamo.srv.html">dynamo.srv</a><a class="sidebar-nav-item" href="migrator.html">migrator.core</a><a class="sidebar-nav-item" href="permacode.html">permacode.core</a><a class="sidebar-nav-item" href="permacode.hasher.html">permacode.hasher</a><a class="sidebar-nav-item" href="permacode.publish.html">permacode.publish</a><a class="sidebar-nav-item" href="permacode.symbols.html">permacode.symbols</a><a class="sidebar-nav-item" href="permacode.validate.html">permacode.validate</a><a class="sidebar-nav-item" href="rabbit-microservices.html">rabbit-microservices.core</a><a class="sidebar-nav-item" href="zk-plan.html">zk-plan.core</a>
    <span class="sidebar-nav-item">&nbsp;</span>
    <span class="sidebar-nav-item">&nbsp;</span>
  </nav>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
	  <a href="index.html"><img src="img/axiom-logo.png"></a>
          <h3 class="masthead-title">
            <span>axiom//dynamo.core</span>
            <small>DynamoDB Integration</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="page">
          <div class="heading">
            <div>
              <h5>Author: Boaz Rosenan&nbsp;&nbsp;<a href="mailto:brosenan@gmail.com">(brosenan@gmail.com)</a></h5>
              <h5>Date: 19 April 2017</h5>
              <h5>Repository: <a href="https://github.com/brosenan/axiom">https://github.com/brosenan/axiom</a></h5>
              <h5>Version: 0.1.0-SNAPSHOT</h5></div></div>
          <hr/>
          <div class="outline">
            <div class="toc">
              <nav data-gumshoe-header>
                <ul data-gumshoe>
                  <a data-scroll class="top" href="#page-top">TOP</a>
                  <li><a class="chapter" data-scroll="" href="#table-kw"><h4>1 &nbsp; table-kw</h4></a></li><li><a class="chapter" data-scroll="" href="#retriever"><h4>2 &nbsp; retriever: An Async Retrieval Function</h4></a></li><li><a class="chapter" data-scroll="" href="#usage-example"><h4>3 &nbsp; Usage Example</h4></a></li><li><a class="chapter" data-scroll="" href="#scanner-scan-a-shard-of-a-table"><h4>4 &nbsp; scanner: Scan a Shard of a Table</h4></a></li>
                </ul>
              </nav>
            </div>
          </div>

          <div class="toc">
              <nav>
                <ul>
                  <li><a class="chapter" data-scroll="" href="#table-kw"><h4>1 &nbsp; table-kw</h4></a></li><li><a class="chapter" data-scroll="" href="#retriever"><h4>2 &nbsp; retriever: An Async Retrieval Function</h4></a></li><li><a class="chapter" data-scroll="" href="#usage-example"><h4>3 &nbsp; Usage Example</h4></a></li><li><a class="chapter" data-scroll="" href="#scanner-scan-a-shard-of-a-table"><h4>4 &nbsp; scanner: Scan a Shard of a Table</h4></a></li>
                </ul>
              </nav>
          </div>
          <div><span id="table-kw"></span><h2><b>1 &nbsp;&nbsp; table-kw</b></h2></div><div><p>The <code>taoensso.faraday</code> library we use uses keywords to convey names of tables and fields. In axiom, table names (the <code>:name</code> field of an event) originate from keywords, but they may contain characters that do not conform to <a href='http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.NamingRulesDataTypes.html'>DynamoDB's naming policy</a>, and in addition, the names used by axiom are fully qualified, and <code>faraday</code> only takes the <code>name</code>.</p></div><div><p>To overcome this, the function <code>table-kw</code> converts the <code>:name</code> attribute of an event to a <code>faraday</code>-compatible keyword.</p></div><div><p>By default, it simply converts a string to a keyword.</p></div><div class="code"><pre><code class="clojure">(table-kw &quot;foo&quot;) =&gt; :foo</code></pre></div><div><p>If the name contains a '/' it is converted to a '.', so that applying <code>name</code> to it will retain the prefix.</p></div><div class="code"><pre><code class="clojure">(name (table-kw &quot;foo/bar&quot;)) =&gt; &quot;foo.bar&quot;</code></pre></div><div><p>Other illegal characters are converted to an underscore ('_').</p></div><div class="code"><pre><code class="clojure">(table-kw &quot;?,:!@#$%^&amp;*-()&quot;) =&gt; :___________-__</code></pre></div><div><span id="retriever"></span><h2><b>2 &nbsp;&nbsp; retriever: An Async Retrieval Function</b></h2></div><div><p>The in <a href='https://brosenan.github.io/axiom/cloudlog-events.html'>cloudlog-events</a>, the <a href='https://brosenan.github.io/axiom/cloudlog-events.html#matcher'>matcher</a> requires some external entity to accept requests in the form of partial events on one channel,  and respond by providing stored events matching the partial ones on another channel.</p></div><div><p><code>retriever</code> is a function, intended to be used from inside a <code>async/thread</code> block, and listens to requests coming on a given channel. For each such request it performs a query according to the parameters provided in the partial event. Then it translates the results to events and pushes them to an output channel provided with the request.</p></div><div><p>To demonstrate this, let's first create two channels: one for the request and one for the response.</p></div><div class="code"><pre><code class="clojure">(def chan-req (async/chan 1000))
 (def chan-res (async/chan 1000))</code></pre></div><div><p>Now let's put a request in the request channel.  The request consists of a partial event and the response channel.</p></div><div class="code"><pre><code class="clojure">(async/&gt;!! chan-req [{:kind :fact
                     :name &quot;foo/bar&quot;
                     :key 123}
                    chan-res])</code></pre></div><div><p><code>retriever</code> is supposed to already run in a <code>thread</code> and wait for this request. In this test we simulate this by calling it after the request is already in the queue.</p></div><div><p>We call <code>retriever</code> with a client options map (see <a href='https://github.com/ptaoussanis/faraday'>faraday's documentation</a>), and the request channel.  Once called, it will perform the following:</p><ol><li>Call <code>faraday</code>'s <code>query</code> method, to get a collection of items (maps).</li><li>Call <code>nippy/thaw</code> to deserialize the body of each event.</li></ol></div><div class="code"><pre><code class="clojure">(retriever ..config.. chan-req) =&gt; true
 (provided
(far/query ..config.. :foo.bar {:key [:eq &quot;123&quot;]})
=&gt; [{:key &quot;123&quot; :ts 1000 :event ..bin1..}
    {:key &quot;123&quot; :ts 1001 :event ..bin2..}]
(nippy/thaw ..bin1..) =&gt; {:data [1 2 3]}
(nippy/thaw ..bin2..) =&gt; {:data [2 3 4]})</code></pre></div><div><p>The events are reconstructed from the items:</p><ul><li>The <code>:kind</code>, <code>:name</code> and <code>:key</code> fields are taken from the request.</li><li>The <code>:ts</code> field is taken from the item, and</li><li>The rest of the fields are taken from the de-serialized <code>:event</code> field in the item.</li></ul></div><div class="code"><pre><code class="clojure">; First event
 (async/alts!! [chan-res
              (async/timeout 100)]) =&gt; [{:kind :fact
                                         :name &quot;foo/bar&quot;
                                         :key 123
                                         :ts 1000
                                         :data [1 2 3]}
                                        chan-res]
 ; Second event
 (async/alts!! [chan-res
              (async/timeout 100)]) =&gt; [{:kind :fact
                                         :name &quot;foo/bar&quot;
                                         :key 123
                                         :ts 1001
                                         :data [2 3 4]}
                                        chan-res]</code></pre></div><div><p>Eventually <code>retriever</code> closes the response channel.</p></div><div class="code"><pre><code class="clojure">(async/alts!! [chan-res
              (async/timeout 100)]) =&gt; [nil chan-res]</code></pre></div><div><p>If the request channel is closed, <code>retriever</code> exits, returning <code>false</code>.</p></div><div class="code"><pre><code class="clojure">(async/close! chan-req)
 (retriever ..config.. chan-req) =&gt; false</code></pre></div><div><span id="usage-example"></span><h2><b>3 &nbsp;&nbsp; Usage Example</b></h2></div><div><p>To see that this library can actually connect to DynamoDB we will use <code>dynamo.srv</code> to create a few events in different tables, and then use <code>retriever</code> to retrieve some of them.</p></div><div><p>We will use a <a href='http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBLocal.html'>local DynamoDB</a> exposed on the local host on port 8006. Our configuration is as follows (we follow <a href='https://github.com/ptaoussanis/faraday#connecting'>these</a> instructions:</p></div><div class="code"><pre><code class="clojure">:integ ; Does not run on usual CI testing
(def client-opts
  {:access-key &quot;FOO&quot;
   :secret-key &quot;BAR&quot;
   :endpoint &quot;http://localhost:8006&quot;})

(srv/init client-opts)</code></pre></div><div><p>Now let's create a bunch of events with different <code>:name</code>, <code>:key</code> and <code>:ts</code> values.</p></div><div class="code"><pre><code class="clojure">(def events
  (for [name [&quot;foo/foo&quot; &quot;foo/bar&quot; &quot;bar/baz&quot;]
        key [&quot;x&quot; :y [&quot;z&quot;]]
        ts [1000 2000 3000]]
    (let [data [name key ts]]
      {:kind :fact
       :name name
       :key key
       :ts ts
       :data data
       :change 1})))</code></pre></div><div><p>Now we use <code>srv/store-fact</code> to store all these events.</p></div><div class="code"><pre><code class="clojure">:integ ; Does not run on usual CI testing
 (doseq [ev events]
 (srv/store-fact ev))</code></pre></div><div><p>Let's fire up a thread to handle retrieval of events.</p></div><div class="code"><pre><code class="clojure">:integ ; Does not run on usual CI testing
 (def req-chan (async/chan 1000))
 (def worker-thread
 (async/thread
   (while (retriever client-opts req-chan))))</code></pre></div><div><p>Out of all the events we created, we are interested in the ones with <code>:name = foo/foo</code> and `:key = ["z"]</p></div><div class="code"><pre><code class="clojure">:integ ; Does not run on usual CI testing
 (let [res-chan (async/chan 1000)]
 (async/&gt;!! req-chan [{:kind :fact
                       :name &quot;foo/foo&quot;
                       :key [&quot;z&quot;]}
                      res-chan])
 (async/alts!! [res-chan
                (async/timeout 1000)]) =&gt; [{:kind :fact
                                            :name &quot;foo/foo&quot;
                                            :key [&quot;z&quot;]
                                            :ts 1000
                                            :data [&quot;foo/foo&quot; [&quot;z&quot;] 1000]
                                            :change 1}
                                           res-chan]
 (async/alts!! [res-chan
                (async/timeout 1000)]) =&gt; [{:kind :fact
                                            :name &quot;foo/foo&quot;
                                            :key [&quot;z&quot;]
                                            :ts 2000
                                            :data [&quot;foo/foo&quot; [&quot;z&quot;] 2000]
                                            :change 1}
                                           res-chan]
 (async/alts!! [res-chan
                (async/timeout 1000)]) =&gt; [{:kind :fact
                                            :name &quot;foo/foo&quot;
                                            :key [&quot;z&quot;]
                                            :ts 3000
                                            :data [&quot;foo/foo&quot; [&quot;z&quot;] 3000]
                                            :change 1}
                                           res-chan]
 (async/alts!! [res-chan
                (async/timeout 1000)]) =&gt; [nil
                                           res-chan])</code></pre></div><div><p>We shut down the service by closing the request channel, and then waiting for the retriever thread to complete by reading from it.</p></div><div class="code"><pre><code class="clojure">:integ ; Does not run on usual CI testing
(async/close! req-chan)
(async/&lt;!! worker-thread)</code></pre></div><div><span id="scanner-scan-a-shard-of-a-table"></span><h2><b>4 &nbsp;&nbsp; scanner: Scan a Shard of a Table</b></h2></div><div><p>For the purpose of data migration we need to process all events in a table. To do this efficiently, we shard the table.</p></div><div><p><code>scanner</code> is given a name of a table, a shard number, a total number of shards and an output channel. It then produces all events from that shard into the channel and closes the channel. It is blocking, and is therefore assumed to be working from within its own thread.</p></div><div class="code"><pre><code class="clojure">(scanner ..config.. ..table.. ..shard.. ..shards.. ..chan..) =&gt; nil
 (provided
(table-kw ..table..) =&gt; ..kw..
(far/scan ..config.. ..kw.. {:segment ..shard..
                             :total-segments ..shards..}) =&gt; [{:key &quot;1&quot; :ts 1000 :event ..bin1..}
                                                              {:key &quot;2&quot; :ts 2000 :event ..bin2..}]
(nippy/thaw ..bin1..) =&gt; {:data [1 2 3]}
(async/&gt;!! ..chan.. {:kind :fact
                     :name ..table..
                     :key 1
                     :ts 1000
                     :data [1 2 3]}) =&gt; irrelevant
(nippy/thaw ..bin2..) =&gt; {:data [2 3 4]}
(async/&gt;!! ..chan.. {:kind :fact
                     :name ..table..
                     :key 2
                     :ts 2000
                     :data [2 3 4]}) =&gt; irrelevant)</code></pre></div>
        </div>
      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

  </body>

  <script>
  if (false) {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', '<@=tracking>', 'caudate.me');
    ga('send', 'pageview');
  }
  </script>
  
  <script type="text/javascript">
    smoothScroll.init();
    gumshoe.init({});
  
    hljs.registerLanguage("clojure",function(e){var t={"builtin-name":"def defonce cond apply if-not if-let if not not= = < > <= >= == + / * - rem quot neg? pos? delay? symbol? keyword? true? false? integer? empty? coll? list? set? ifn? fn? associative? sequential? sorted? counted? reversible? number? decimal? class? distinct? isa? float? rational? reduced? ratio? odd? even? char? seq? vector? string? map? nil? contains? zero? instance? not-every? not-any? libspec? -> ->> .. . inc compare do dotimes mapcat take remove take-while drop letfn drop-last take-last drop-while while intern condp case reduced cycle split-at split-with repeat replicate iterate range merge zipmap declare line-seq sort comparator sort-by dorun doall nthnext nthrest partition eval doseq await await-for let agent atom send send-off release-pending-sends add-watch mapv filterv remove-watch agent-error restart-agent set-error-handler error-handler set-error-mode! error-mode shutdown-agents quote var fn loop recur throw try monitor-enter monitor-exit defmacro defn defn- macroexpand macroexpand-1 for dosync and or when when-not when-let comp juxt partial sequence memoize constantly complement identity assert peek pop doto proxy defstruct first rest cons defprotocol cast coll deftype defrecord last butlast sigs reify second ffirst fnext nfirst nnext defmulti defmethod meta with-meta ns in-ns create-ns import refer keys select-keys vals key val rseq name namespace promise into transient persistent! conj! assoc! dissoc! pop! disj! use class type num float double short byte boolean bigint biginteger bigdec print-method print-dup throw-if printf format load compile get-in update-in pr pr-on newline flush read slurp read-line subvec with-open memfn time re-find re-groups rand-int rand mod locking assert-valid-fdecl alias resolve ref deref refset swap! reset! set-validator! compare-and-set! alter-meta! reset-meta! commute get-validator alter ref-set ref-history-count ref-min-history ref-max-history ensure sync io! new next conj set! to-array future future-call into-array aset gen-class reduce map filter find empty hash-map hash-set sorted-map sorted-map-by sorted-set sorted-set-by vec vector seq flatten reverse assoc dissoc list disj get union difference intersection extend extend-type extend-protocol int nth delay count concat chunk chunk-buffer chunk-append chunk-first chunk-rest max min dec unchecked-inc-int unchecked-inc unchecked-dec-inc unchecked-dec unchecked-negate unchecked-add-int unchecked-add unchecked-subtract-int unchecked-subtract chunk-next chunk-cons chunked-seq? prn vary-meta lazy-seq spread list* str find-keyword keyword symbol gensym force rationalize"},r="a-zA-Z_\\-!.?+*=<>&#'",n="["+r+"]["+r+"0-9/;:]*",a="[-+]?\\d+(\\.\\d+)?",o={b:n,r:0},s={cN:"number",b:a,r:0},i=e.inherit(e.QSM,{i:null}),c=e.C(";","$",{r:0}),d={cN:"literal",b:/\b(true|false|nil)\b/},l={b:"[\\[\\{]",e:"[\\]\\}]"},m={cN:"comment",b:"\\^"+n},p=e.C("\\^\\{","\\}"),u={cN:"symbol",b:"[:]{1,2}"+n},f={b:"\\(",e:"\\)"},h={eW:!0,r:0},y={k:t,l:n,cN:"name",b:n,starts:h},b=[f,i,m,p,c,u,l,s,d,o];return f.c=[e.C("comment",""),y,h],h.c=b,l.c=b,{aliases:["clj"],i:/\S/,c:[f,i,m,p,c,u,l,s,d]}});
    hljs.initHighlightingOnLoad();
  </script>
</html>
