
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <link rel="shortcut icon" href="favicon.ico">
  <title>axiom//dynamo.core - DynamoDB Integration</title>
  <script src="js/highlight.min.js"></script>
  <script src="js/gumshoe.min.js"></script>
  <script src="js/smooth-scroll.min.js"></script>
  
  <!-- CSS -->
  <link rel="stylesheet" href="css/poole.css">
  <link rel="stylesheet" href="css/syntax.css">
  <link rel="stylesheet" href="css/lanyon.css">
  <link rel="stylesheet" href="css/bolton.css">
  <link rel="stylesheet" href="css/bolton-api.css">
  <link rel="stylesheet" href="css/bolton-highlight.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">
  
</head>

  <body class="theme-base-08">
    <span id="page-top"></span>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <nav class="sidebar-nav">
    <span>&nbsp;</span>
    <a class="sidebar-nav-item header" href="index.html"><img src="img/logo-white.png"/></a>
    <span>&nbsp;</span>
    <a class="sidebar-nav-item" href="axiom-clj.html">axiom-clj.core</a><a class="sidebar-nav-item" href="cloudlog.html">cloudlog.core</a><a class="sidebar-nav-item" href="cloudlog-events.html">cloudlog-events.core</a><a class="sidebar-nav-item" href="cloudlog.graph.html">cloudlog.graph</a><a class="sidebar-nav-item" href="cloudlog.interset.html">cloudlog.interset</a><a class="sidebar-nav-item" href="di.html">di.core</a><a class="sidebar-nav-item" href="docs.html"></a><a class="sidebar-nav-item active" href="dynamo.html">dynamo.core</a><a class="sidebar-nav-item" href="gateway.html">gateway.core</a><a class="sidebar-nav-item" href="migrator.html">migrator.core</a><a class="sidebar-nav-item" href="permacode.html">permacode.core</a><a class="sidebar-nav-item" href="permacode.hasher.html">permacode.hasher</a><a class="sidebar-nav-item" href="permacode.publish.html">permacode.publish</a><a class="sidebar-nav-item" href="permacode.symbols.html">permacode.symbols</a><a class="sidebar-nav-item" href="permacode.validate.html">permacode.validate</a><a class="sidebar-nav-item" href="rabbit-microservices.html">rabbit-microservices.core</a><a class="sidebar-nav-item" href="s3.html">s3.core</a><a class="sidebar-nav-item" href="storm.html">storm.core</a><a class="sidebar-nav-item" href="zk-plan.html">zk-plan.core</a>
    <span class="sidebar-nav-item">&nbsp;</span>
    <span class="sidebar-nav-item">&nbsp;</span>
  </nav>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
	  <a href="index.html"><img src="img/axiom-logo.png"></a>
          <h3 class="masthead-title">
            <span>axiom//dynamo.core</span>
            <small>DynamoDB Integration</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="page">
          <div class="heading">
            <div>
              <h5>Author: Boaz Rosenan&nbsp;&nbsp;<a href="mailto:brosenan@gmail.com">(brosenan@gmail.com)</a></h5>
              <h5>Date: 06 July 2017</h5>
              <h5>Repository: <a href="https://github.com/brosenan/axiom">https://github.com/brosenan/axiom</a></h5>
              <h5>Version: 0.1.0-SNAPSHOT</h5></div></div>
          <hr/>
          <div class="outline">
            <div class="toc">
              <nav data-gumshoe-header>
                <ul data-gumshoe>
                  <a data-scroll class="top" href="#page-top">dynamo.core</a>
                  <li><a class="chapter" data-scroll="" href="#database-chan"><h4>1 &nbsp; database-chan: A Channel for Database Queries</h4></a></li><li><a class="chapter" data-scroll="" href="#database-retriever"><h4>2 &nbsp; database-retriever: A Function for Retrieving Events from DynamoDB</h4></a></li><li><a class="chapter" data-scroll="" href="#database-event-storage"><h4>3 &nbsp; database-event-storage: A Function for Storing Events</h4></a></li><li><a class="chapter" data-scroll="" href="#store-fact"><h4>4 &nbsp; store-fact (service): Stores Fact Events</h4></a></li><li><a class="chapter" data-scroll="" href="#database-event-storage-chan"><h4>5 &nbsp; database-event-storage-chan: A Channel for Storing Events in the Database</h4></a></li><li><a class="chapter" data-scroll="" href="#database-scanner"><h4>6 &nbsp; database-scanner: Scan a Shard of a Table</h4></a></li><li><a class="chapter" data-scroll="" href="#usage-example"><h4>7 &nbsp; Usage Example</h4></a></li><li><a class="chapter" data-scroll="" href="#under-the-hood"><h4>8 &nbsp; Under the Hood</h4></a><a class="section" data-scroll="" href="#table-kw"><h5><i>8.1 &nbsp; table-kw</i></h5></a><a class="section" data-scroll="" href="#database-tables"><h5><i>8.2 &nbsp; database-tables</i></h5></a><a class="section" data-scroll="" href="#database-ensure-table"><h5><i>8.3 &nbsp; database-ensure-table</i></h5></a></li>
                </ul>
              </nav>
            </div>
          </div>

          <div class="toc">
              <nav>
                <ul>
                  <li><a class="chapter" data-scroll="" href="#database-chan"><h4>1 &nbsp; database-chan: A Channel for Database Queries</h4></a></li><li><a class="chapter" data-scroll="" href="#database-retriever"><h4>2 &nbsp; database-retriever: A Function for Retrieving Events from DynamoDB</h4></a></li><li><a class="chapter" data-scroll="" href="#database-event-storage"><h4>3 &nbsp; database-event-storage: A Function for Storing Events</h4></a></li><li><a class="chapter" data-scroll="" href="#store-fact"><h4>4 &nbsp; store-fact (service): Stores Fact Events</h4></a></li><li><a class="chapter" data-scroll="" href="#database-event-storage-chan"><h4>5 &nbsp; database-event-storage-chan: A Channel for Storing Events in the Database</h4></a></li><li><a class="chapter" data-scroll="" href="#database-scanner"><h4>6 &nbsp; database-scanner: Scan a Shard of a Table</h4></a></li><li><a class="chapter" data-scroll="" href="#usage-example"><h4>7 &nbsp; Usage Example</h4></a></li><li><a class="chapter" data-scroll="" href="#under-the-hood"><h4>8 &nbsp; Under the Hood</h4></a><a class="section" data-scroll="" href="#table-kw"><h5><i>8.1 &nbsp; table-kw</i></h5></a><a class="section" data-scroll="" href="#database-tables"><h5><i>8.2 &nbsp; database-tables</i></h5></a><a class="section" data-scroll="" href="#database-ensure-table"><h5><i>8.3 &nbsp; database-ensure-table</i></h5></a></li>
                </ul>
              </nav>
          </div>
          <div><span id="database-chan"></span><h2><b>1 &nbsp;&nbsp; database-chan: A Channel for Database Queries</b></h2></div><div><p>The in <a href='https://brosenan.github.io/axiom/cloudlog-events.html'>cloudlog-events</a>, the <a href='https://brosenan.github.io/axiom/cloudlog-events.html#matcher'>matcher</a> requires some external entity to accept requests in the form of partial events on one channel,  and respond by providing stored events matching the partial ones on another channel.</p></div><div><p><code>database-chan</code> is a <a href='di.html'>dependency-injection resource</a> which is a <code>core.async</code> channel on which requests can be posted.</p></div><div><p><code>database-chan</code> depends on the following resources:</p><ol><li><code>database-retriever</code>: a function that retrieves data from the database.</li><li><code>num-database-retriever-threads</code>: a number determining the number of threads to be spawned.</li></ol></div><div><p>In the example below we inject a mock retriever function. It will get a response channel from the request channel, and then output two events to it, and close it.</p></div><div class="code"><pre><code class="clojure">(let [$ (di/injector {:database-retriever (fn [chan]
                                           (let [[_ resp-chan] (async/&lt;!! chan)]
                                             (async/&gt;!! resp-chan {:event 1})
                                             (async/&gt;!! resp-chan {:event 2})
                                             (async/close! resp-chan)))
                     :num-database-retriever-threads 1})]
 (module $)
 (di/startup $)
 (let [chan-req (di/do-with! $ [database-chan] database-chan)
       chan-res (async/chan 10)]
   (async/&gt;!! chan-req [{:some :request} chan-res])
   (async/&lt;!! chan-res) =&gt; {:event 1}
   (async/&lt;!! chan-res) =&gt; {:event 2}
   (async/&lt;!! chan-res) =&gt; nil))</code></pre></div><div><span id="database-retriever"></span><h2><b>2 &nbsp;&nbsp; database-retriever: A Function for Retrieving Events from DynamoDB</b></h2></div><div><p><code>database-retriever</code> is a function that retrieves data from DynamoDB.<br /> It is a DI-resource that depends on <code>dynamodb-config</code> &ndash; a map containing credentials and other details for connecting to DynamoDB  (see <a href='https://github.com/ptaoussanis/faraday#connecting'>faraday's documentation</a> for more details), and <code>database-ensure-table</code> to ensure the table exists before accessing it.</p></div><div class="code"><pre><code class="clojure">(def table-ensured (atom nil))
 (let [$ (di/injector {:dynamodb-config :some-config
                     :dynamodb-get-tables (fn [conf] [])
                     :database-ensure-table (fn [table]
                                              (reset! table-ensured table))})]
 (module $)
 (di/startup $)
 (def database-retriever (di/do-with! $ [database-retriever] database-retriever)))</code></pre></div><div><p>To demonstrate how it works, let's create two channels: a request channel and a response channel.</p></div><div class="code"><pre><code class="clojure">(def chan-req (async/chan 1000))
 (def chan-res (async/chan 1000))</code></pre></div><div><p>Now let's put a request in the request channel.  The request consists of a partial event and the response channel.</p></div><div class="code"><pre><code class="clojure">(async/&gt;!! chan-req [{:kind :fact
                     :name &quot;foo/bar&quot;
                     :key 123}
                    chan-res])</code></pre></div><div><p>We call <code>database-retriever</code> with a client options map (see <a href='https://github.com/ptaoussanis/faraday'>faraday's documentation</a>), and the request channel.  Once called, it will perform the following:</p><ol><li>Call <code>faraday</code>'s <code>query</code> method, to get a collection of items (maps).</li><li>Call <code>nippy/thaw</code> to deserialize the body of each event.</li></ol></div><div class="code"><pre><code class="clojure">(database-retriever chan-req) =&gt; true
 (provided
(far/query :some-config :foo.bar {:key [:eq &quot;123&quot;]})
=&gt; [{:key &quot;123&quot; :ts 1000 :event ..bin1..}
    {:key &quot;123&quot; :ts 1001 :event ..bin2..}]
(nippy/thaw ..bin1..) =&gt; {:data [1 2 3]}
(nippy/thaw ..bin2..) =&gt; {:data [2 3 4]})</code></pre></div><div><p>It also ensured that the table exists by calling (our mock) <code>database-ensure-table</code>.</p></div><div class="code"><pre><code class="clojure">@table-ensured =&gt; :foo.bar</code></pre></div><div><p>The events are reconstructed from the items:</p><ul><li>The <code>:kind</code>, <code>:name</code> and <code>:key</code> fields are taken from the request.</li><li>The <code>:ts</code> field is taken from the item, and</li><li>The rest of the fields are taken from the de-serialized <code>:event</code> field in the item.</li></ul></div><div class="code"><pre><code class="clojure">; First event
 (async/alts!! [chan-res
              (async/timeout 100)]) =&gt; [{:kind :fact
                                         :name &quot;foo/bar&quot;
                                         :key 123
                                         :ts 1000
                                         :data [1 2 3]}
                                        chan-res]
                                      ; Second event
 (async/alts!! [chan-res
              (async/timeout 100)]) =&gt; [{:kind :fact
                                         :name &quot;foo/bar&quot;
                                         :key 123
                                         :ts 1001
                                         :data [2 3 4]}
                                        chan-res]</code></pre></div><div><p>Eventually <code>database-retriever</code> closes the response channel.</p></div><div class="code"><pre><code class="clojure">(async/alts!! [chan-res
              (async/timeout 100)]) =&gt; [nil chan-res]</code></pre></div><div><p>If the request channel is closed, <code>database-retriever</code> exits, returning <code>false</code>.</p></div><div class="code"><pre><code class="clojure">(async/close! chan-req)
 (database-retriever chan-req) =&gt; false</code></pre></div><div><span id="database-event-storage"></span><h2><b>3 &nbsp;&nbsp; database-event-storage: A Function for Storing Events</b></h2></div><div><p><code>database-event-storage</code> is a function for storing events in the database.</p></div><div><p>It is a DI resource that depends on the following resources:</p><ol><li><code>dynamodb-config</code>: The DynamoDB credentials and coordinates, and</li><li><a href='#database-ensure-table'>database-ensure-table</a>: a function that makes sure the given table exists.</li></ol></div><div class="code"><pre><code class="clojure">(def table-ensured (atom nil))
 (let [$ (di/injector {:dynamodb-config :config
                     :database-ensure-table (fn [table]
                                              (reset! table-ensured table))
                     :database-tables (atom #{})
                     :dynamodb-default-throughput 0})]
 (module $)
 (di/startup $)
 (def database-event-storage (di/do-with! $ [database-event-storage] database-event-storage)))</code></pre></div><div><p><code>database-event-storage</code> takes an event and stores it in DynamoDB.</p></div><div class="code"><pre><code class="clojure">(def my-event {:kind :fact
              :name &quot;foo&quot;
              :key 1234
              :data [1 2 3 4]
              :ts 1000
              :change 1
              :writers #{}
              :readers #{}})
 (database-event-storage my-event) =&gt; nil
 (provided
(nippy/freeze {:data [1 2 3 4]
               :change 1
               :writers #{}
               :readers #{}}) =&gt; ..bin..
(far/put-item :config :foo {:key &quot;1234&quot;
                            :ts 1000
                            :event ..bin..}) =&gt; irrelevant)</code></pre></div><div><p>It ensures the table exists by calling (our mock) <code>database-ensure-table</code>.</p></div><div class="code"><pre><code class="clojure">@table-ensured =&gt; :foo</code></pre></div><div><p>Events with <code>:name</code> values that end with "?" or "!" should not be persisted, and are therefore ignored.</p></div><div class="code"><pre><code class="clojure">(database-event-storage (assoc my-event :name &quot;foo?&quot;)) =&gt; nil
 (provided
                                      ; No side effect
)
 (database-event-storage (assoc my-event :name &quot;bar!&quot;)) =&gt; nil
 (provided
                                      ; No side effect
)</code></pre></div><div><span id="store-fact"></span><h2><b>4 &nbsp;&nbsp; store-fact (service): Stores Fact Events</b></h2></div><div><p><code>store-fact</code> is a microservice function that subscribes to all fact events. It depends on the following resources:</p><ol><li><code>declare-service</code>: a function that creates a queue and binds it to receive certain events</li><li><code>assign-service</code>: a function that registers it to certain events,</li><li><a href='#database-event-storage'>database-event-storage</a>.</li></ol></div><div><p>The service is merely a serving of <code>database-event-storage</code>, registered to all fact events. We will demonstrate it by mocking the <code>serve</code> function to push its parameters to a channel.</p></div><div class="code"><pre><code class="clojure">(let [calls (transient [])
     $ (di/injector {:declare-service (fn [key reg] (conj! calls [:declare-service key reg]))
                     :assign-service (fn [key func] (conj! calls [:assign-service key func]))
                     :database-event-storage :the-storage-func})]
 (module $)
 (di/startup $)
 (persistent! calls) =&gt; [[:declare-service &quot;database-event-storage&quot; {:kind :fact}]
                         [:assign-service &quot;database-event-storage&quot; :the-storage-func]])</code></pre></div><div><span id="database-event-storage-chan"></span><h2><b>5 &nbsp;&nbsp; database-event-storage-chan: A Channel for Storing Events in the Database</b></h2></div><div><p>While <a href='#store-fact#'>store-fact</a> allows us to store system-wide fact events to the database, we sometimes wish to store events events without publishing them system-wide. <code>database-event-storage-chan</code> is a <code>core.async</code> <em>channel</em> that allows storing of event into the database without publishing them system-wide.</p></div><div><p><code>database-event-storage-chan</code> depends on the following resources:</p><ol><li><a href='#database-event-storage'>database-event-storage</a></li><li><code>dynamodb-event-storage-num-threads</code>: The number of threads to be spawned for this task.</li></ol></div><div><p>In the following example we will demonstrate how it works by mocking <code>database-event-storage</code> to conj the given event to a sequence stored in an atom.</p></div><div class="code"><pre><code class="clojure">(def db (atom '()))
 (let [$ (di/injector {:database-event-storage (fn [ev]
                                               (swap! db #(conj % ev)))
                     :dynamodb-event-storage-num-threads 2})]
 (module $)
 (di/startup $)
 (def database-event-storage-chan (di/do-with! $ [database-event-storage-chan] database-event-storage-chan)))</code></pre></div><div><p>We operate the channel by sending it pairs: <code>&#91;ev ack&#93;</code>, where <code>ev</code> is the event we wish to store, and <code>ack</code> is a fresh channel we use to get acknowledgement through. Once the event is safely stored, <code>ack</code> will be closed.</p></div><div class="code"><pre><code class="clojure">(let [[ack1 ack2 ack3] (for [_ (range 3)] (async/chan))]
 (async/&gt;!! database-event-storage-chan [:ev1 ack1])
 (async/&gt;!! database-event-storage-chan [:ev2 ack2])
 (async/&gt;!! database-event-storage-chan [:ev3 ack3])
 (async/alts!! [ack1 (async/timeout 1000)]) =&gt; [nil ack1]
 (async/alts!! [ack2 (async/timeout 1000)]) =&gt; [nil ack2]
 (async/alts!! [ack3 (async/timeout 1000)]) =&gt; [nil ack3])
 (set @db) =&gt; #{:ev1 :ev2 :ev3}</code></pre></div><div><span id="database-scanner"></span><h2><b>6 &nbsp;&nbsp; database-scanner: Scan a Shard of a Table</b></h2></div><div><p>For the purpose of data migration we need to process all events in a table. To do this efficiently, we shard the table.</p></div><div><p><code>database-scanner</code> depends on <code>dynamodb-config</code> for credentials to DynamoDB, and on <code>database-ensure-table</code> to ensure the table exists before issuing the actual scan request.</p></div><div class="code"><pre><code class="clojure">(def table-ensured (atom nil))
 (let [$ (di/injector {:dynamodb-config :some-config
                     :database-ensure-table (fn [table]
                                              (reset! table-ensured table))
                     :dynamodb-get-tables (fn [conf] []) ;; Irrelevant to this test
                     })]
 (module $)
 (di/startup $)
 (def database-scanner (di/do-with! $ [database-scanner] database-scanner)))</code></pre></div><div><p><code>database-scanner</code> is given a name of a table, a shard number, a total number of shards and an output channel. It then produces all events from that shard into the channel and closes the channel. It is blocking, and is therefore assumed to be working from within its own thread.</p></div><div class="code"><pre><code class="clojure">(database-scanner &quot;foo/bar&quot; ..shard.. ..shards.. ..chan..) =&gt; nil
 (provided
(far/scan :some-config :foo.bar {:segment ..shard..
                                 :total-segments ..shards..}) =&gt; [{:key &quot;1&quot; :ts 1000 :event ..bin1..}
                                                                  {:key &quot;2&quot; :ts 2000 :event ..bin2..}]
(nippy/thaw ..bin1..) =&gt; {:data [1 2 3]}
(async/&gt;!! ..chan.. {:kind :fact
                     :name &quot;foo/bar&quot;
                     :key 1
                     :ts 1000
                     :data [1 2 3]}) =&gt; irrelevant
(nippy/thaw ..bin2..) =&gt; {:data [2 3 4]}
(async/&gt;!! ..chan.. {:kind :fact
                     :name &quot;foo/bar&quot;
                     :key 2
                     :ts 2000
                     :data [2 3 4]}) =&gt; irrelevant
(async/close! ..chan..) =&gt; irrelevant)</code></pre></div><div><p>Before issuing the scan, <code>database-scanner</code> calls <code>database-ensure-table</code> to make sure the table exists.</p></div><div class="code"><pre><code class="clojure">@table-ensured =&gt; :foo.bar</code></pre></div><div><span id="usage-example"></span><h2><b>7 &nbsp;&nbsp; Usage Example</b></h2></div><div><p>To see that this library can actually connect to DynamoDB we will use the <code>store-fact</code> service to create a few events in different tables, and then use <code>database-chan</code> to retrieve some of them.</p></div><div><p>We will use a <a href='http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBLocal.html'>local DynamoDB</a> exposed on the local host on port 8006. Our configuration is as follows (we follow <a href='https://github.com/ptaoussanis/faraday#connecting'>these</a> instructions:</p></div><div class="code"><pre><code class="clojure">:integ ; Does not run on usual CI testing
 (def client-opts
 {:access-key &quot;FOO&quot;
  :secret-key &quot;BAR&quot;
  :endpoint &quot;http://localhost:8006&quot;})</code></pre></div><div><p>We will use a real <a href='rabbit-microservices.html'>rabbitmq microservice</a> to store the facts in the database. We will use <a href='di.html'>dependency injection</a> to initialize the needed services.</p></div><div class="code"><pre><code class="clojure">:integ ; Does not run on usual CI testing
 (let [$ (di/injector {:dynamodb-config client-opts
                     :num-database-retriever-threads 1
                     :dynamodb-default-throughput {:read 1 :write 1}
                     :rabbitmq-config langohr.core/*default-config*})]
 (module $)
 (rabbit-microservices.core/module $)
 (di/startup $)
 (di/do-with! $ [database-chan publish]
              (def req-chan database-chan)
              (def publish publish)))</code></pre></div><div><p>Now let's create a bunch of events with different <code>:name</code>, <code>:key</code> and <code>:ts</code> values.</p></div><div class="code"><pre><code class="clojure">(def events
  (for [name [&quot;foo/foo&quot; &quot;foo/bar&quot; &quot;bar/baz&quot;]
        key [&quot;x&quot; :y [&quot;z&quot;]]
        ts [1000 2000 3000]]
    (let [data [name key ts]]
      {:kind :fact
       :name name
       :key key
       :ts ts
       :data data
       :change 1})))</code></pre></div><div><p>We will <a href='rabbit-microservices.html#publish'>publish</a> each event to have the <a href='#store-fact'>store-fact service</a> store them to DynamoDB.</p></div><div class="code"><pre><code class="clojure">:integ ; Does not run on usual CI testing
 (doseq [ev events]
 (publish ev))</code></pre></div><div><p>Let's wait to give all the events time to get stored.</p></div><div class="code"><pre><code class="clojure">:integ ; Does not run on usual CI testing
 (Thread/sleep 5000)</code></pre></div><div><p>Out of all the events we created, we are interested in the ones with <code>:name = foo/foo</code> and `:key = ["z"]</p></div><div class="code"><pre><code class="clojure">:integ ; Does not run on usual CI testing
 (let [res-chan (async/chan 1000)]
 (async/&gt;!! req-chan [{:kind :fact
                       :name &quot;foo/foo&quot;
                       :key [&quot;z&quot;]}
                      res-chan])
 (async/alts!! [res-chan
                (async/timeout 1000)]) =&gt; [{:kind :fact
                                            :name &quot;foo/foo&quot;
                                            :key [&quot;z&quot;]
                                            :ts 1000
                                            :data [&quot;foo/foo&quot; [&quot;z&quot;] 1000]
                                            :change 1}
                                           res-chan]
 (async/alts!! [res-chan
                (async/timeout 1000)]) =&gt; [{:kind :fact
                                            :name &quot;foo/foo&quot;
                                            :key [&quot;z&quot;]
                                            :ts 2000
                                            :data [&quot;foo/foo&quot; [&quot;z&quot;] 2000]
                                            :change 1}
                                           res-chan]
 (async/alts!! [res-chan
                (async/timeout 1000)]) =&gt; [{:kind :fact
                                            :name &quot;foo/foo&quot;
                                            :key [&quot;z&quot;]
                                            :ts 3000
                                            :data [&quot;foo/foo&quot; [&quot;z&quot;] 3000]
                                            :change 1}
                                           res-chan]
 (async/alts!! [res-chan
                (async/timeout 1000)]) =&gt; [nil
                                           res-chan])</code></pre></div><div><p>We shut down the service by closing the request channel.</p></div><div class="code"><pre><code class="clojure">:integ ; Does not run on usual CI testing
 (async/close! req-chan)</code></pre></div><div><span id="under-the-hood"></span><h2><b>8 &nbsp;&nbsp; Under the Hood</b></h2></div><div><span id="table-kw"></span><h3>8.1 &nbsp;&nbsp; table-kw</h3></div><div><p>The <code>taoensso.faraday</code> library we use uses keywords to convey names of tables and fields. In axiom, table names (the <code>:name</code> field of an event) originate from keywords, but they may contain characters that do not conform to <a href='http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.NamingRulesDataTypes.html'>DynamoDB's naming policy</a>, and in addition, the names used by axiom are fully qualified, and <code>faraday</code> only takes the <code>name</code>.</p></div><div><p>To overcome this, the function <code>table-kw</code> converts the <code>:name</code> attribute of an event to a <code>faraday</code>-compatible keyword.</p></div><div><p>By default, it simply converts a string to a keyword.</p></div><div class="code"><pre><code class="clojure">(table-kw &quot;foo&quot;) =&gt; :foo</code></pre></div><div><p>If the name contains a '/' it is converted to a '.', so that applying <code>name</code> to it will retain the prefix.</p></div><div class="code"><pre><code class="clojure">(name (table-kw &quot;foo/bar&quot;)) =&gt; &quot;foo.bar&quot;</code></pre></div><div><p>Other illegal characters are converted to an underscore ('_').</p></div><div class="code"><pre><code class="clojure">(table-kw &quot;?,:!@#$%^&amp;*-()&quot;) =&gt; :___________-__</code></pre></div><div><span id="database-tables"></span><h3>8.2 &nbsp;&nbsp; database-tables</h3></div><div><p><code>database-tables</code> is an atom containing a set of table keywords currently in the database. It depends on:</p><ol><li><code>dynamodb-config</code>: the database credentials, and</li><li><code>dynamodb-get-tables</code>: a function to get the list of tables.The latter is intended for testing and is provided by this module to be <code>far/list-tables</code>.</li></ol></div><div class="code"><pre><code class="clojure">(let [$ (di/injector {:dynamodb-config :config
                     :dynamodb-get-tables (fn [config]
                                            [config :foo :bar])})]
 (module $)
 (di/startup $)
 (di/do-with! $ [database-tables]
              @database-tables) =&gt; #{:foo :bar :config})</code></pre></div><div><span id="database-ensure-table"></span><h3>8.3 &nbsp;&nbsp; database-ensure-table</h3></div><div><p>Sometimes, before performing operations such as storing an event or starting a scan we want to ensure that the table we have at hand actually exists. If it doesn't, or we don't know it exists, we wish to create it. We count on DynamoDB's ignoring re-creation of tables that already exist.</p></div><div><p><code>database-ensure-table</code> is based on the following:</p><ol><li><a href='#database-tables'>database-tables</a>: the set of currently known tables,</li><li><code>dynamodb-default-throughput</code>: a map containing the default configuration for a new table, and</li><li><code>dynamodb-config</code>: credentials to talk to DynamoDB.</li></ol></div><div class="code"><pre><code class="clojure">(let [$ (di/injector {:database-tables (atom #{:foo :bar})
                     :dynamodb-default-throughput {:default :throughput}
                     :dynamodb-config :config})]
 (module $)
 (di/startup $)
 (def database-ensure-table (di/do-with! $ [database-ensure-table] database-ensure-table))
 (def database-tables (di/do-with! $ [database-tables] database-tables)))</code></pre></div><div><p><code>database-ensure-table</code> is a function that takes a name of a table (as a keyword). If the table exists in <code>database-tables</code>, it does nothing.</p></div><div class="code"><pre><code class="clojure">(database-ensure-table :foo) =&gt; nil
 (provided
;; No calls
)</code></pre></div><div><p>However, if the table does not exist in <code>database-tables</code>, <code>database-ensure-table</code> creates a table in DynamoDB.</p></div><div class="code"><pre><code class="clojure">(database-ensure-table :other-table) =&gt; nil
 (provided
(far/ensure-table :config :other-table [:key :s] ; :key is the partition key
                  {:range-keydef [:ts :n] ; and :ts is the range key
                   :throughput {:default :throughput}
                   :block true}) =&gt; irrelevant)</code></pre></div><div><p>After ensuring a table exists, the table is added to <code>database-tables</code>.</p></div><div class="code"><pre><code class="clojure">@database-tables =&gt; #{:foo :bar :other-table}</code></pre></div><div><p>In case of a failure due to a wrong state, the operation succeeds &ndash;  after all, the table couldn't have been in the wrong state if it hadn't existed...</p></div><div class="code"><pre><code class="clojure">(database-ensure-table :yet-another) =&gt; nil
 (provided
(far/ensure-table :config :yet-another [:key :s] ; :key is the partition key
                  {:range-keydef [:ts :n] ; and :ts is the range key
                   :throughput {:default :throughput}
                   :block true})
=throws=&gt; (com.amazonaws.services.dynamodbv2.model.ResourceInUseException. &quot;bad state...&quot;))</code></pre></div><div><p>The <code>database-tables</code> set is still updated (we know the table exists).</p></div><div class="code"><pre><code class="clojure">@database-tables =&gt; #{:foo :bar :other-table :yet-another}</code></pre></div>
        </div>
      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>
  </body>

  <script>
  if (false) {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', '<@=tracking>', 'caudate.me');
    ga('send', 'pageview');
  }
  </script>
  
  <script type="text/javascript">
    smoothScroll.init();
    gumshoe.init({});
  
    hljs.registerLanguage("clojure",function(e){var t={"builtin-name":"def defonce cond apply if-not if-let if not not= = < > <= >= == + / * - rem quot neg? pos? delay? symbol? keyword? true? false? integer? empty? coll? list? set? ifn? fn? associative? sequential? sorted? counted? reversible? number? decimal? class? distinct? isa? float? rational? reduced? ratio? odd? even? char? seq? vector? string? map? nil? contains? zero? instance? not-every? not-any? libspec? -> ->> .. . inc compare do dotimes mapcat take remove take-while drop letfn drop-last take-last drop-while while intern condp case reduced cycle split-at split-with repeat replicate iterate range merge zipmap declare line-seq sort comparator sort-by dorun doall nthnext nthrest partition eval doseq await await-for let agent atom send send-off release-pending-sends add-watch mapv filterv remove-watch agent-error restart-agent set-error-handler error-handler set-error-mode! error-mode shutdown-agents quote var fn loop recur throw try monitor-enter monitor-exit defmacro defn defn- macroexpand macroexpand-1 for dosync and or when when-not when-let comp juxt partial sequence memoize constantly complement identity assert peek pop doto proxy defstruct first rest cons defprotocol cast coll deftype defrecord last butlast sigs reify second ffirst fnext nfirst nnext defmulti defmethod meta with-meta ns in-ns create-ns import refer keys select-keys vals key val rseq name namespace promise into transient persistent! conj! assoc! dissoc! pop! disj! use class type num float double short byte boolean bigint biginteger bigdec print-method print-dup throw-if printf format load compile get-in update-in pr pr-on newline flush read slurp read-line subvec with-open memfn time re-find re-groups rand-int rand mod locking assert-valid-fdecl alias resolve ref deref refset swap! reset! set-validator! compare-and-set! alter-meta! reset-meta! commute get-validator alter ref-set ref-history-count ref-min-history ref-max-history ensure sync io! new next conj set! to-array future future-call into-array aset gen-class reduce map filter find empty hash-map hash-set sorted-map sorted-map-by sorted-set sorted-set-by vec vector seq flatten reverse assoc dissoc list disj get union difference intersection extend extend-type extend-protocol int nth delay count concat chunk chunk-buffer chunk-append chunk-first chunk-rest max min dec unchecked-inc-int unchecked-inc unchecked-dec-inc unchecked-dec unchecked-negate unchecked-add-int unchecked-add unchecked-subtract-int unchecked-subtract chunk-next chunk-cons chunked-seq? prn vary-meta lazy-seq spread list* str find-keyword keyword symbol gensym force rationalize"},r="a-zA-Z_\\-!.?+*=<>&#'",n="["+r+"]["+r+"0-9/;:]*",a="[-+]?\\d+(\\.\\d+)?",o={b:n,r:0},s={cN:"number",b:a,r:0},i=e.inherit(e.QSM,{i:null}),c=e.C(";","$",{r:0}),d={cN:"literal",b:/\b(true|false|nil)\b/},l={b:"[\\[\\{]",e:"[\\]\\}]"},m={cN:"comment",b:"\\^"+n},p=e.C("\\^\\{","\\}"),u={cN:"symbol",b:"[:]{1,2}"+n},f={b:"\\(",e:"\\)"},h={eW:!0,r:0},y={k:t,l:n,cN:"name",b:n,starts:h},b=[f,i,m,p,c,u,l,s,d,o];return f.c=[e.C("comment",""),y,h],h.c=b,l.c=b,{aliases:["clj"],i:/\S/,c:[f,i,m,p,c,u,l,s,d]}});
    hljs.initHighlightingOnLoad();
  </script>
</html>
